// src/app/mod.rs
// --------------
// src/app/mod.rs
// --------------
//
// Only change here is that ClipmapUpload now has x/y/w/h, so this compiles.

use std::sync::Arc;
use std::time::Instant;

use winit::{
    event::*,
    event_loop::{ControlFlow, EventLoop},
    window::Window,
};

use crate::{
    camera::Camera,
    clipmap::Clipmap,
    config,
    input::InputState,
    render::{CameraGpu, ClipmapGpu, OverlayGpu, Renderer},
    streaming::ChunkManager,
    world::WorldGen,
};

pub async fn run(event_loop: EventLoop<()>, window: Arc<Window>) {
    let mut app = App::new(window).await;

    event_loop
        .run(move |event, elwt| {
            elwt.set_control_flow(ControlFlow::Wait);

            match &event {
                Event::AboutToWait => {
                    app.window.request_redraw();
                }
                Event::WindowEvent {
                    event: WindowEvent::RedrawRequested,
                    ..
                } => {
                    app.frame(elwt);
                }
                _ => {
                    app.handle_event(event, elwt);
                }
            }
        })
        .unwrap();
}

pub struct App {
    window: Arc<Window>,
    start_time: Instant,

    _instance: wgpu::Instance,
    surface: wgpu::Surface<'static>,
    _adapter: wgpu::Adapter,
    _surface_format: wgpu::TextureFormat,
    config: wgpu::SurfaceConfiguration,

    renderer: Renderer,

    world: Arc<WorldGen>,
    chunks: ChunkManager,

    clipmap: Clipmap,

    input: InputState,
    camera: Camera,

    fps_value: u32,
    fps_frames: u32,
    fps_last: Instant,
}

impl App {
    pub async fn new(window: Arc<Window>) -> Self {
        let start_time = Instant::now();
        let size = window.inner_size();

        let instance = wgpu::Instance::default();
        let surface = instance.create_surface(window.clone()).unwrap();

        let adapter = instance
            .request_adapter(&wgpu::RequestAdapterOptions {
                compatible_surface: Some(&surface),
                power_preference: wgpu::PowerPreference::HighPerformance,
                force_fallback_adapter: false,
            })
            .await
            .unwrap();

        let surface_caps = surface.get_capabilities(&adapter);
        let surface_format = surface_caps.formats[0];

        let config_sc = wgpu::SurfaceConfiguration {
            usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
            format: surface_format,
            width: size.width.max(1),
            height: size.height.max(1),
            present_mode: surface_caps.present_modes[0],
            alpha_mode: surface_caps.alpha_modes[0],
            view_formats: vec![],
            desired_maximum_frame_latency: 2,
        };

        let renderer =
            Renderer::new(&adapter, surface_format, config_sc.width, config_sc.height).await;

        surface.configure(renderer.device(), &config_sc);

        let world = Arc::new(WorldGen::new(12345));
        let chunks = ChunkManager::new(world.clone());

        let camera = Camera::new(config_sc.width as f32 / config_sc.height as f32);
        let input = InputState::default();

        let clipmap = Clipmap::new();

        Self {
            window,
            start_time,
            _instance: instance,
            surface,
            _adapter: adapter,
            _surface_format: surface_format,
            config: config_sc,
            renderer,
            world,
            chunks,
            clipmap,
            input,
            camera,
            fps_value: 0,
            fps_frames: 0,
            fps_last: Instant::now(),
        }
    }

    pub fn handle_event(
        &mut self,
        event: Event<()>,
        elwt: &winit::event_loop::EventLoopWindowTarget<()>,
    ) {
        match event {
            Event::DeviceEvent { event, .. } => {
                self.input.on_device_event(&event);
            }

            Event::WindowEvent { event, .. } => {
                let _ = self.input.on_window_event(&event, &self.window);

                match event {
                    WindowEvent::CloseRequested => elwt.exit(),

                    WindowEvent::Resized(new_size) => {
                        self.config.width = new_size.width.max(1);
                        self.config.height = new_size.height.max(1);

                        self.surface.configure(self.renderer.device(), &self.config);
                        self.renderer
                            .resize_output(self.config.width, self.config.height);

                        // IMPORTANT: the resize recreated clip_height, so force reupload next frame
                        self.clipmap.invalidate_all();
                    }

                    _ => {}
                }
            }

            Event::AboutToWait => self.frame(elwt),

            _ => {}
        }
    }

    fn frame(&mut self, elwt: &winit::event_loop::EventLoopWindowTarget<()>) {
        // 1) camera integrate
        self.camera.integrate_input(&mut self.input);

        // 2) streaming update
        let cam_pos = self.camera.position();
        let cam_fwd = self.camera.forward();
        let grid_changed = self.chunks.update(&self.world, cam_pos, cam_fwd);
        if grid_changed {
            self.renderer.write_chunk_grid(self.chunks.chunk_grid());
        }

        // 3) clipmap update + uploads
        let t = self.start_time.elapsed().as_secs_f32();
        let (clip_params_cpu, clip_uploads) = self.clipmap.update(self.world.as_ref(), cam_pos, t);

        let clip_gpu = ClipmapGpu::from_cpu(&clip_params_cpu);
        self.renderer.write_clipmap(&clip_gpu);

        for up in clip_uploads {
            self.renderer
                .write_clipmap_patch(up.level, up.x, up.y, up.w, up.h, &up.data_f16);
        }

        // 4) camera matrices -> CameraGpu
        let aspect = self.config.width as f32 / self.config.height as f32;
        let cf = self.camera.frame_matrices(aspect);

        let max_steps = (config::CHUNK_SIZE * 2).clamp(48, 96);

        let cam_gpu = CameraGpu {
            view_inv: cf.view_inv.to_cols_array_2d(),
            proj_inv: cf.proj_inv.to_cols_array_2d(),
            cam_pos: [cf.pos.x, cf.pos.y, cf.pos.z, 1.0],

            chunk_size: config::CHUNK_SIZE,
            chunk_count: self.chunks.chunk_count(),
            max_steps,
            _pad0: 0,

            voxel_params: [config::VOXEL_SIZE_M_F32, t, 2.0, 0.002],

            grid_origin_chunk: [
                self.chunks.grid_origin()[0],
                self.chunks.grid_origin()[1],
                self.chunks.grid_origin()[2],
                0,
            ],
            grid_dims: [
                self.chunks.grid_dims()[0],
                self.chunks.grid_dims()[1],
                self.chunks.grid_dims()[2],
                0,
            ],
        };

        self.renderer.write_camera(&cam_gpu);

        // 5) fps overlay
        self.fps_frames += 1;
        let dt = self.fps_last.elapsed().as_secs_f32();
        if dt >= 0.25 {
            let fps = (self.fps_frames as f32) / dt;
            self.fps_value = fps.round() as u32;
            self.fps_frames = 0;
            self.fps_last = Instant::now();
        }

        let overlay = OverlayGpu {
            fps: self.fps_value,
            width: self.config.width,
            height: self.config.height,
            _pad0: 0,
        };
        self.renderer.write_overlay(&overlay);

        // 6) update scene buffers if changed
        self.renderer.apply_chunk_uploads(self.chunks.take_uploads());

        // 7) acquire frame + encode passes
        let frame = match self.surface.get_current_texture() {
            Ok(f) => f,

            Err(wgpu::SurfaceError::Lost | wgpu::SurfaceError::Outdated) => {
                self.surface.configure(self.renderer.device(), &self.config);
                return;
            }

            Err(wgpu::SurfaceError::Timeout) => return,

            Err(wgpu::SurfaceError::OutOfMemory) => {
                elwt.exit();
                return;
            }
        };

        let frame_view = frame.texture.create_view(&Default::default());

        let mut encoder = self
            .renderer
            .device()
            .create_command_encoder(&wgpu::CommandEncoderDescriptor {
                label: Some("encoder"),
            });

        self.renderer
            .encode_compute(&mut encoder, self.config.width, self.config.height);

        self.renderer.encode_blit(&mut encoder, &frame_view);

        self.renderer.queue().submit(Some(encoder.finish()));
        frame.present();
    }
}

// src/camera.rs
// -------------
// src/camera.rs
use glam::{Mat4, Vec3};

use crate::{config, input::InputState};

pub struct Camera {
    pos: Vec3,
    yaw: f32,
    pitch: f32,
    fovy_rad: f32,
    z_near: f32,
    z_far: f32,
    // movement tuning
    speed_per_frame: f32,
    mouse_sens: f32,
}

pub struct CameraFrame {
    pub view_inv: Mat4,
    pub proj_inv: Mat4,
    pub pos: Vec3,
}

impl Camera {
    pub fn new(aspect: f32) -> Self {
        let _ = aspect; // kept for future (if you want aspect-dependent params)
        Self {
            pos: Vec3::new((config::CHUNK_SIZE as f32 * config::VOXEL_SIZE_M_F32) * 0.5, 20.0, -20.0),
            yaw: 0.0,
            pitch: 0.15,
            fovy_rad: 60.0_f32.to_radians(),
            z_near: 0.1,
            z_far: 1000.0,
            speed_per_frame: 0.35,
            mouse_sens: 0.0025,
        }
    }

    pub fn position(&self) -> Vec3 {
        self.pos
    }

    pub fn forward(&self) -> glam::Vec3 {
        let (yaw, pitch) = (self.yaw, self.pitch);
        glam::Vec3::new(
            yaw.sin() * pitch.cos(),
            pitch.sin(),
            yaw.cos() * pitch.cos(),
        )
        .normalize()
    }

    pub fn integrate_input(&mut self, input: &mut InputState) {
        // mouse look
        if input.focused {
            let (dx, dy) = input.take_mouse_delta();
            self.yaw -= dx * self.mouse_sens;
            self.pitch = (self.pitch - dy * self.mouse_sens).clamp(-1.55, 1.55);
        } else {
            // still clear deltas
            let _ = input.take_mouse_delta();
        }

        // basis
        let forward = Vec3::new(
            self.yaw.sin() * self.pitch.cos(),
            self.pitch.sin(),
            self.yaw.cos() * self.pitch.cos(),
        )
        .normalize();

        let right = forward.cross(Vec3::Y).normalize();
        let up = right.cross(forward).normalize();

        // movement (per-frame like your original)
        let k = input.keys;
        let mut vel = Vec3::ZERO;
        if k.w { vel += forward; }
        if k.s { vel -= forward; }
        if k.d { vel += right; }
        if k.a { vel -= right; }
        if k.space { vel += up; }
        if k.alt { vel -= up; }

        if vel.length_squared() > 0.0 {
            self.pos += vel.normalize() * self.speed_per_frame;
        }
    }

    pub fn frame_matrices(&self, aspect: f32) -> CameraFrame {
        let forward = Vec3::new(
            self.yaw.sin() * self.pitch.cos(),
            self.pitch.sin(),
            self.yaw.cos() * self.pitch.cos(),
        )
        .normalize();

        let view = Mat4::look_at_rh(self.pos, self.pos + forward, Vec3::Y);
        let proj = Mat4::perspective_rh(self.fovy_rad, aspect, self.z_near, self.z_far);

        CameraFrame {
            view_inv: view.inverse(),
            proj_inv: proj.inverse(),
            pos: self.pos,
        }
    }
}

// src/clipmap.rs
// --------------
// src/clipmap.rs
// --------------
//
// CPU-updated 2D clipmap height texture data (nested levels around camera).
//
// FP16 OPTIMIZATION:
// - Each level stores CLIPMAP_RES * CLIPMAP_RES heights in *half float* (u16 bits).
// - This halves upload bandwidth and reduces VRAM traffic.
// - WGSL textureLoad still returns f32 when sampling R16Float.
//
// Strategy (ring clipmap / strip updates):
// - Each level is a CLIPMAP_RES x CLIPMAP_RES height map (meters) stored as a TORUS.
// - Level i has cell size = CLIPMAP_BASE_CELL_M * 2^i.
// - We "snap" the *logical* origin (world cell coords) to cell boundaries for stability.
// - When the origin changes by a small delta (dx,dz in cells), we DO NOT full refresh.
//   Instead we:
//     1) advance a per-level torus offset (texel origin) by (dx,dz)
//     2) upload only the newly exposed rows/columns as strip patches
// - Shader maps world->logical texel (0..res-1) then applies torus offset modulo res.
//
// Uniform packing (per level):
// - We keep the clipmap uniform array as vec4<f32> per level.
// - We store:
//     x = origin_x_m
//     y = origin_z_m
//     z = cell_size_m
//     w = packed offsets (u16 off_x | (u16 off_z << 16)) bitcast via f32 bits
// - We KEEP inv_cell_size_m on CPU side for any legacy uses, but shader can compute 1/cell.
//

use glam::Vec3;

use crate::{config, world::WorldGen};

#[derive(Clone, Copy, Debug)]
pub struct ClipLevelParams {
    pub origin_x_m: f32,
    pub origin_z_m: f32,
    pub cell_size_m: f32,
    pub inv_cell_size_m: f32,
    /// Packed torus offsets: off_x in low 16 bits, off_z in high 16 bits.
    pub packed_offsets: u32,
}

/// CPU-side clipmap params (fed into GPU packing in `render/gpu_types.rs`).
#[derive(Clone, Copy, Debug)]
pub struct ClipmapParamsCpu {
    pub levels: u32,
    pub res: u32,
    pub base_cell_m: f32,
    pub _pad0: f32,
    pub level: [ClipLevelParams; config::CLIPMAP_LEVELS_USIZE],
}

/// A sub-rectangle upload into a clipmap level texture layer.
///
/// IMPORTANT: this struct used to be `{ level, data_f16 }` in your tree, which is
/// why you were seeing the E0609 errors. Ring/strip updates require the rect.
pub struct ClipmapUpload {
    pub level: u32,
    pub x: u32,
    pub y: u32,
    pub w: u32,
    pub h: u32,
    /// w*h heights, FP16 bits (IEEE-754 half), row-major for the patch.
    pub data_f16: Vec<u16>,
}

pub struct Clipmap {
    last_origin_cell: [(i32, i32); config::CLIPMAP_LEVELS_USIZE],
    /// Toroidal storage offset per level (in texels).
    /// Mapping: storage = (logical + offset) mod res
    tex_offset: [(u16, u16); config::CLIPMAP_LEVELS_USIZE],
    last_update_time_s: [f32; config::CLIPMAP_LEVELS_USIZE],
}

impl Clipmap {
    pub fn new() -> Self {
        Self {
            last_origin_cell: [(i32::MIN, i32::MIN); config::CLIPMAP_LEVELS_USIZE],
            tex_offset: [(0, 0); config::CLIPMAP_LEVELS_USIZE],
            last_update_time_s: [f32::NEG_INFINITY; config::CLIPMAP_LEVELS_USIZE],
        }
    }

    #[inline]
    fn level_cell_size(i: u32) -> f32 {
        config::CLIPMAP_BASE_CELL_M * (1u32 << i) as f32
    }

    /// Compute snapped origin in *cell coordinates* (integer grid), for a given camera xz.
    ///
    /// We keep the camera roughly centered in the texture:
    /// origin = snap(cam - (res/2)*cell).
    #[inline]
    fn snapped_origin_cell(cam_x_m: f32, cam_z_m: f32, cell_m: f32) -> (i32, i32) {
        let half = (config::CLIPMAP_RES as f32) * 0.5;
        let ox_m = cam_x_m - half * cell_m;
        let oz_m = cam_z_m - half * cell_m;

        let ox_c = (ox_m / cell_m).floor() as i32;
        let oz_c = (oz_m / cell_m).floor() as i32;
        (ox_c, oz_c)
    }

    #[inline]
    fn cell_to_origin_m(cell_x: i32, cell_z: i32, cell_m: f32) -> (f32, f32) {
        (cell_x as f32 * cell_m, cell_z as f32 * cell_m)
    }

    #[inline]
    fn pack_offsets(off_x: u16, off_z: u16) -> u32 {
        (off_x as u32) | ((off_z as u32) << 16)
    }

    #[inline]
    fn wrap_i32_mod_u16(v: i32, m: i32) -> u16 {
        let mut r = v % m;
        if r < 0 {
            r += m;
        }
        r as u16
    }

    // -------------------------------------------------------------------------
    // f32 -> f16 (bits) conversion, IEEE-754 half precision
    // -------------------------------------------------------------------------
    #[inline]
    fn f32_to_f16_bits(v: f32) -> u16 {
        let x = v.to_bits();

        let sign = ((x >> 16) & 0x8000) as u16;
        let exp = ((x >> 23) & 0xFF) as i32;
        let mant = x & 0x007F_FFFF;

        // NaN/Inf
        if exp == 255 {
            if mant == 0 {
                return sign | 0x7C00; // Inf
            } else {
                let payload = (mant >> 13) as u16;
                return sign | 0x7C00 | (payload.max(1));
            }
        }

        // Unbias exponent from f32, then bias to f16
        let e = exp - 127;
        let e16 = e + 15;

        // Too large => Inf
        if e16 >= 31 {
            return sign | 0x7C00;
        }

        // Too small => subnormal or zero
        if e16 <= 0 {
            if e16 < -10 {
                return sign;
            }

            let m = mant | 0x0080_0000;

            let shift = 14 - e16;
            let mut mant16 = (m >> shift) as u16;

            // Round to nearest-even
            let rem_mask = (1u32 << shift) - 1;
            let rem = m & rem_mask;
            let half = 1u32 << (shift - 1);

            if rem > half || (rem == half && (mant16 & 1) != 0) {
                mant16 = mant16.wrapping_add(1);
            }

            return sign | mant16;
        }

        // Normal f16
        let mut mant16 = (mant >> 13) as u16;

        let round_bits = mant & 0x0000_1FFF;
        if round_bits > 0x1000 || (round_bits == 0x1000 && (mant16 & 1) != 0) {
            mant16 = mant16.wrapping_add(1);

            // Mantissa overflow => bump exponent
            if mant16 & 0x0400 != 0 {
                mant16 = 0;
                let e_out = (e16 + 1) as u16;
                if e_out >= 31 {
                    return sign | 0x7C00;
                }
                return sign | (e_out << 10) | mant16;
            }
        }

        sign | ((e16 as u16) << 10) | (mant16 & 0x03FF)
    }

    #[inline]
    fn sample_height_f16(world: &WorldGen, wx_m: f32, wz_m: f32) -> u16 {
        let vs = config::VOXEL_SIZE_M_F32;

        let wx_vx = (wx_m / vs).floor() as i32;
        let wz_vx = (wz_m / vs).floor() as i32;

        let h_vx = world.ground_height(wx_vx, wz_vx);
        let h_m = (h_vx as f32) * vs;

        Self::f32_to_f16_bits(h_m)
    }

    fn build_full_level(world: &WorldGen, ox_m: f32, oz_m: f32, cell_m: f32) -> Vec<u16> {
        let res = config::CLIPMAP_RES as usize;
        let mut data = vec![0u16; res * res];

        for tz in 0..res {
            let wz_m = oz_m + (tz as f32 + 0.5) * cell_m;
            let row = tz * res;

            for tx in 0..res {
                let wx_m = ox_m + (tx as f32 + 0.5) * cell_m;
                data[row + tx] = Self::sample_height_f16(world, wx_m, wz_m);
            }
        }

        data
    }

    fn build_row_patch(
        world: &WorldGen,
        ox_m: f32,
        oz_m: f32,
        cell_m: f32,
        logical_z0: u32,
        rows: u32,
    ) -> Vec<u16> {
        let res = config::CLIPMAP_RES as usize;
        let w = res as u32;

        let h = rows as usize;
        let mut data = vec![0u16; (w as usize) * h];

        for rz in 0..rows {
            let lz = logical_z0 + rz;
            let wz_m = oz_m + (lz as f32 + 0.5) * cell_m;

            let row = (rz as usize) * res;
            for tx in 0..res {
                let wx_m = ox_m + (tx as f32 + 0.5) * cell_m;
                data[row + tx] = Self::sample_height_f16(world, wx_m, wz_m);
            }
        }

        data
    }

    fn build_col_patch(
        world: &WorldGen,
        ox_m: f32,
        oz_m: f32,
        cell_m: f32,
        logical_x0: u32,
        cols: u32,
    ) -> Vec<u16> {
        let res = config::CLIPMAP_RES as usize;
        let w = cols as usize;
        let h = res;

        let mut data = vec![0u16; w * h];

        for tz in 0..res {
            let wz_m = oz_m + (tz as f32 + 0.5) * cell_m;
            let row = tz * w;

            for cx in 0..cols {
                let lx = logical_x0 + cx;
                let wx_m = ox_m + (lx as f32 + 0.5) * cell_m;
                data[row + (cx as usize)] = Self::sample_height_f16(world, wx_m, wz_m);
            }
        }

        data
    }

    /// Update clipmap data around camera.
    ///
    /// Returns:
    /// - CPU params for GPU packing
    /// - uploads:
    ///     - full refresh on first touch or huge jump
    ///     - otherwise strip patches (rows/cols)
    pub fn update(
        &mut self,
        world: &WorldGen,
        cam_pos_m: Vec3,
        time_s: f32,
    ) -> (ClipmapParamsCpu, Vec<ClipmapUpload>) {
        let mut params = ClipmapParamsCpu {
            levels: config::CLIPMAP_LEVELS,
            res: config::CLIPMAP_RES,
            base_cell_m: config::CLIPMAP_BASE_CELL_M,
            _pad0: 0.0,
            level: [ClipLevelParams {
                origin_x_m: 0.0,
                origin_z_m: 0.0,
                cell_size_m: 1.0,
                inv_cell_size_m: 1.0,
                packed_offsets: 0,
            }; config::CLIPMAP_LEVELS_USIZE],
        };

        let mut uploads = Vec::new();

        let res_u = config::CLIPMAP_RES;
        let res_i = res_u as i32;

        for i in 0..config::CLIPMAP_LEVELS {
            let li = i as usize;
            let cell_m = Self::level_cell_size(i);
            let inv_cell_m = 1.0 / cell_m.max(1e-6);

            let (new_ox_c, new_oz_c) = Self::snapped_origin_cell(cam_pos_m.x, cam_pos_m.z, cell_m);
            let (new_ox_m, new_oz_m) = Self::cell_to_origin_m(new_ox_c, new_oz_c, cell_m);

            // Current torus offsets
            let (mut off_x, mut off_z) = self.tex_offset[li];

            let (old_ox_c, old_oz_c) = self.last_origin_cell[li];
            let first = old_ox_c == i32::MIN;

            let dx = if first { 0 } else { new_ox_c - old_ox_c };
            let dz = if first { 0 } else { new_oz_c - old_oz_c };

            let mut want_update = first || dx != 0 || dz != 0;

            let allow_by_time =
                (time_s - self.last_update_time_s[li]) >= config::CLIPMAP_MIN_UPDATE_INTERVAL_S;

            if !allow_by_time {
                want_update = false;
            }

            if want_update {
                self.last_update_time_s[li] = time_s;

                if first {
                    // Full refresh first time
                    self.last_origin_cell[li] = (new_ox_c, new_oz_c);
                    off_x = 0;
                    off_z = 0;
                    self.tex_offset[li] = (off_x, off_z);

                    let full = Self::build_full_level(world, new_ox_m, new_oz_m, cell_m);
                    uploads.push(ClipmapUpload {
                        level: i,
                        x: 0,
                        y: 0,
                        w: res_u,
                        h: res_u,
                        data_f16: full,
                    });
                } else {
                    let adx = dx.unsigned_abs() as u32;
                    let adz = dz.unsigned_abs() as u32;
                    let big_jump = adx >= res_u || adz >= res_u;

                    if big_jump {
                        // Teleport-scale jump: full refresh
                        self.last_origin_cell[li] = (new_ox_c, new_oz_c);
                        off_x = 0;
                        off_z = 0;
                        self.tex_offset[li] = (off_x, off_z);

                        let full = Self::build_full_level(world, new_ox_m, new_oz_m, cell_m);
                        uploads.push(ClipmapUpload {
                            level: i,
                            x: 0,
                            y: 0,
                            w: res_u,
                            h: res_u,
                            data_f16: full,
                        });
                    } else {
                        // Scroll torus offsets
                        off_x = Self::wrap_i32_mod_u16((off_x as i32) + dx, res_i);
                        off_z = Self::wrap_i32_mod_u16((off_z as i32) + dz, res_i);
                        self.tex_offset[li] = (off_x, off_z);
                        self.last_origin_cell[li] = (new_ox_c, new_oz_c);

                        // logical -> storage
                        let map_x = |lx: u32| -> u32 { (lx + (off_x as u32)) % res_u };
                        let map_z = |lz: u32| -> u32 { (lz + (off_z as u32)) % res_u };

                        // New columns
                        if dx != 0 {
                            let cols = dx.unsigned_abs() as u32;

                            if dx > 0 {
                                // logical [res-cols .. res-1]
                                let logical_x0 = res_u - cols;
                                let sx0 = map_x(logical_x0);
                                let end = sx0 + cols;

                                if end <= res_u {
                                    let data = Self::build_col_patch(
                                        world, new_ox_m, new_oz_m, cell_m, logical_x0, cols,
                                    );
                                    uploads.push(ClipmapUpload {
                                        level: i,
                                        x: sx0,
                                        y: 0,
                                        w: cols,
                                        h: res_u,
                                        data_f16: data,
                                    });
                                } else {
                                    let a = res_u - sx0;
                                    let b = end - res_u;

                                    let data_a = Self::build_col_patch(
                                        world, new_ox_m, new_oz_m, cell_m, logical_x0, a,
                                    );
                                    uploads.push(ClipmapUpload {
                                        level: i,
                                        x: sx0,
                                        y: 0,
                                        w: a,
                                        h: res_u,
                                        data_f16: data_a,
                                    });

                                    let data_b = Self::build_col_patch(
                                        world, new_ox_m, new_oz_m, cell_m, logical_x0 + a, b,
                                    );
                                    uploads.push(ClipmapUpload {
                                        level: i,
                                        x: 0,
                                        y: 0,
                                        w: b,
                                        h: res_u,
                                        data_f16: data_b,
                                    });
                                }
                            } else {
                                // dx < 0: logical [0 .. cols-1]
                                let logical_x0 = 0;
                                let sx0 = map_x(logical_x0);
                                let end = sx0 + cols;

                                if end <= res_u {
                                    let data = Self::build_col_patch(
                                        world, new_ox_m, new_oz_m, cell_m, logical_x0, cols,
                                    );
                                    uploads.push(ClipmapUpload {
                                        level: i,
                                        x: sx0,
                                        y: 0,
                                        w: cols,
                                        h: res_u,
                                        data_f16: data,
                                    });
                                } else {
                                    let a = res_u - sx0;
                                    let b = end - res_u;

                                    let data_a = Self::build_col_patch(
                                        world, new_ox_m, new_oz_m, cell_m, logical_x0, a,
                                    );
                                    uploads.push(ClipmapUpload {
                                        level: i,
                                        x: sx0,
                                        y: 0,
                                        w: a,
                                        h: res_u,
                                        data_f16: data_a,
                                    });

                                    let data_b = Self::build_col_patch(
                                        world, new_ox_m, new_oz_m, cell_m, logical_x0 + a, b,
                                    );
                                    uploads.push(ClipmapUpload {
                                        level: i,
                                        x: 0,
                                        y: 0,
                                        w: b,
                                        h: res_u,
                                        data_f16: data_b,
                                    });
                                }
                            }
                        }

                        // New rows
                        if dz != 0 {
                            let rows = dz.unsigned_abs() as u32;

                            if dz > 0 {
                                // logical [res-rows .. res-1]
                                let logical_z0 = res_u - rows;
                                let sy0 = map_z(logical_z0);
                                let end = sy0 + rows;

                                if end <= res_u {
                                    let data = Self::build_row_patch(
                                        world, new_ox_m, new_oz_m, cell_m, logical_z0, rows,
                                    );
                                    uploads.push(ClipmapUpload {
                                        level: i,
                                        x: 0,
                                        y: sy0,
                                        w: res_u,
                                        h: rows,
                                        data_f16: data,
                                    });
                                } else {
                                    let a = res_u - sy0;
                                    let b = end - res_u;

                                    let data_a = Self::build_row_patch(
                                        world, new_ox_m, new_oz_m, cell_m, logical_z0, a,
                                    );
                                    uploads.push(ClipmapUpload {
                                        level: i,
                                        x: 0,
                                        y: sy0,
                                        w: res_u,
                                        h: a,
                                        data_f16: data_a,
                                    });

                                    let data_b = Self::build_row_patch(
                                        world, new_ox_m, new_oz_m, cell_m, logical_z0 + a, b,
                                    );
                                    uploads.push(ClipmapUpload {
                                        level: i,
                                        x: 0,
                                        y: 0,
                                        w: res_u,
                                        h: b,
                                        data_f16: data_b,
                                    });
                                }
                            } else {
                                // dz < 0: logical [0 .. rows-1]
                                let logical_z0 = 0;
                                let sy0 = map_z(logical_z0);
                                let end = sy0 + rows;

                                if end <= res_u {
                                    let data = Self::build_row_patch(
                                        world, new_ox_m, new_oz_m, cell_m, logical_z0, rows,
                                    );
                                    uploads.push(ClipmapUpload {
                                        level: i,
                                        x: 0,
                                        y: sy0,
                                        w: res_u,
                                        h: rows,
                                        data_f16: data,
                                    });
                                } else {
                                    let a = res_u - sy0;
                                    let b = end - res_u;

                                    let data_a = Self::build_row_patch(
                                        world, new_ox_m, new_oz_m, cell_m, logical_z0, a,
                                    );
                                    uploads.push(ClipmapUpload {
                                        level: i,
                                        x: 0,
                                        y: sy0,
                                        w: res_u,
                                        h: a,
                                        data_f16: data_a,
                                    });

                                    let data_b = Self::build_row_patch(
                                        world, new_ox_m, new_oz_m, cell_m, logical_z0 + a, b,
                                    );
                                    uploads.push(ClipmapUpload {
                                        level: i,
                                        x: 0,
                                        y: 0,
                                        w: res_u,
                                        h: b,
                                        data_f16: data_b,
                                    });
                                }
                            }
                        }
                    }
                }
            }

            let packed = Self::pack_offsets(off_x, off_z);
            params.level[li] = ClipLevelParams {
                origin_x_m: new_ox_m,
                origin_z_m: new_oz_m,
                cell_size_m: cell_m,
                inv_cell_size_m: inv_cell_m,
                packed_offsets: packed,
            };
        }

        (params, uploads)
    }

    pub fn invalidate_all(&mut self) {
        self.last_origin_cell = [(i32::MIN, i32::MIN); config::CLIPMAP_LEVELS_USIZE];
        self.tex_offset = [(0, 0); config::CLIPMAP_LEVELS_USIZE];
        self.last_update_time_s = [f32::NEG_INFINITY; config::CLIPMAP_LEVELS_USIZE];
    }
}

// src/config.rs
// -------------
// src/config.rs
// -------------
// Global config knobs for the voxel/SVO renderer + streaming.

pub const CHUNK_SIZE: u32 = 64;

pub const ACTIVE_RADIUS: i32 = 8;
pub const KEEP_RADIUS: i32 = ACTIVE_RADIUS + 7;

pub const VOXEL_SIZE_M_F32: f32 = 0.10;
pub const VOXEL_SIZE_M_F64: f64 = 0.10;

// Keep this explicit so you can change voxel size later without hunting constants.
pub const VOXELS_PER_METER: i32 = 10; // 1.0 / 0.10

pub const WORKER_THREADS: usize = 4;
pub const MAX_IN_FLIGHT: usize = 8;

// GPU node arena budget (storage buffer capacity).
pub const NODE_BUDGET_BYTES: usize = 1024 * 1024 * 1024; // 1 GB

// CPU chunk cache budget (SVO nodes stored on CPU so we don't rebuild chunks).
// This is the *total* bytes of cached NodeGpu arrays across all cached chunks.
pub const CHUNK_CACHE_BUDGET_BYTES: usize = 1024 * 1024 * 1024; // 1024 MB

// -----------------------------------------------------------------------------
// Clipmap (far terrain fallback)
// -----------------------------------------------------------------------------
//
// A set of nested 2D height textures around the camera (CPU updated).
// The primary compute shader samples this when the SVO grid doesn't cover the ray
// (or when no voxel hit occurs).
//
// Height units: meters (f32).
//
// NOTE: These constants MUST match shader-side constants in `shaders/clipmap.wgsl`.

pub const CLIPMAP_LEVELS: u32 = 8;
pub const CLIPMAP_LEVELS_USIZE: usize = CLIPMAP_LEVELS as usize;

// Texture resolution per level (square).
pub const CLIPMAP_RES: u32 = 512;

// Base cell size (meters) for level 0. Level i cell size = BASE * 2^i.
pub const CLIPMAP_BASE_CELL_M: f32 = 0.25;

// How often we allow a full refresh per level at most (seconds).
// (Prevents thrashing if you ever tie updates to very tiny camera jitter.)
pub const CLIPMAP_MIN_UPDATE_INTERVAL_S: f32 = 0.0;

// src/input.rs
// ------------
// src/input.rs
use winit::{
    event::{DeviceEvent, ElementState, KeyEvent, WindowEvent},
    keyboard::{KeyCode, PhysicalKey},
    window::{CursorGrabMode, Window},
};

#[derive(Default, Clone, Copy)]
pub struct KeyState {
    pub w: bool,
    pub a: bool,
    pub s: bool,
    pub d: bool,
    pub space: bool,
    pub alt: bool,
}

impl KeyState {
    pub fn set(&mut self, code: KeyCode, down: bool) {
        match code {
            KeyCode::KeyW => self.w = down,
            KeyCode::KeyA => self.a = down,
            KeyCode::KeyS => self.s = down,
            KeyCode::KeyD => self.d = down,
            KeyCode::Space => self.space = down,
            KeyCode::AltLeft | KeyCode::AltRight => self.alt = down,
            _ => {}
        }
    }
}

#[derive(Default)]
pub struct InputState {
    pub keys: KeyState,
    pub focused: bool,
    pub mouse_dx: f32,
    pub mouse_dy: f32,
}

impl InputState {
    pub fn on_device_event(&mut self, event: &DeviceEvent) {
        if !self.focused {
            return;
        }
        if let DeviceEvent::MouseMotion { delta } = event {
            self.mouse_dx += delta.0 as f32;
            self.mouse_dy += delta.1 as f32;
        }
    }

    /// Returns true if event is fully handled/consumed.
    pub fn on_window_event(&mut self, event: &WindowEvent, window: &Window) -> bool {
        match event {
            WindowEvent::Focused(f) => {
                self.focused = *f;
                if self.focused {
                    let _ = window
                        .set_cursor_grab(CursorGrabMode::Locked)
                        .or_else(|_| window.set_cursor_grab(CursorGrabMode::Confined));
                    window.set_cursor_visible(false);
                } else {
                    let _ = window.set_cursor_grab(CursorGrabMode::None);
                    window.set_cursor_visible(true);
                }
                true
            }

            WindowEvent::KeyboardInput { event, .. } => {
                if let KeyEvent {
                    physical_key: PhysicalKey::Code(code),
                    state,
                    ..
                } = event
                {
                    let down = *state == ElementState::Pressed;
                    self.keys.set(*code, down);

                    if down && *code == KeyCode::Escape {
                        self.focused = false;
                        let _ = window.set_cursor_grab(CursorGrabMode::None);
                        window.set_cursor_visible(true);
                        return true;
                    }
                }
                false
            }

            _ => false,
        }
    }

    pub fn take_mouse_delta(&mut self) -> (f32, f32) {
        let dx = self.mouse_dx;
        let dy = self.mouse_dy;
        self.mouse_dx = 0.0;
        self.mouse_dy = 0.0;
        (dx, dy)
    }
}

// src/main.rs
// -----------
// src/main.rs
mod app;
mod camera;
mod clipmap;
mod config;
mod input;
mod render;
mod streaming;
mod svo;
mod world;

use std::sync::Arc;
use winit::{
    dpi::PhysicalSize,
    event_loop::EventLoop,
    window::{Fullscreen, WindowBuilder},
};

fn main() {
    let event_loop = EventLoop::new().unwrap();

    let window = Arc::new(
        WindowBuilder::new()
            .with_title("SVO MVP")
            .with_inner_size(PhysicalSize::new(1280, 720))
            .build(&event_loop)
            .unwrap(),
    );
    window.set_fullscreen(Some(Fullscreen::Borderless(None)));

    pollster::block_on(app::run(event_loop, window));
}

// src/render/gpu_types.rs
// -----------------------
// src/render/gpu_types.rs
// -----------------------
//
// Fix: ClipLevelParams now has `packed_offsets`, but we keep its existing
// `inv_cell_size_m` field on CPU side.
// GPU uniform uses vec4 per level with packed offsets in .w.

use bytemuck::{Pod, Zeroable};

#[repr(C)]
#[derive(Clone, Copy, Pod, Zeroable, Debug)]
pub struct NodeGpu {
    pub child_base: u32,
    pub child_mask: u32,
    pub material: u32,
    pub _pad: u32,
}

#[repr(C)]
#[derive(Clone, Copy, Pod, Zeroable)]
pub struct ChunkMetaGpu {
    pub origin: [i32; 4],
    pub node_base: u32,
    pub node_count: u32,
    pub _pad0: u32,
    pub _pad1: u32,
}

#[repr(C)]
#[derive(Clone, Copy, Pod, Zeroable)]
pub struct CameraGpu {
    pub view_inv: [[f32; 4]; 4],
    pub proj_inv: [[f32; 4]; 4],
    pub cam_pos: [f32; 4],

    pub chunk_size: u32,
    pub chunk_count: u32,
    pub max_steps: u32,
    pub _pad0: u32,

    pub voxel_params: [f32; 4],

    pub grid_origin_chunk: [i32; 4],
    pub grid_dims: [u32; 4],
}

/// Clipmap uniform payload.
///
/// Matches `shaders/clipmap.wgsl`.
///
/// Per level vec4:
///   x = origin_x_m
///   y = origin_z_m
///   z = cell_size_m
///   w = packed offsets bits (off_x u16 | (off_z u16 << 16)) stored via f32::from_bits
#[repr(C)]
#[derive(Clone, Copy, Pod, Zeroable)]
pub struct ClipmapGpu {
    pub levels: u32,
    pub res: u32,
    pub base_cell_m: f32,
    pub _pad0: f32,

    pub level: [[f32; 4]; crate::config::CLIPMAP_LEVELS_USIZE],
}

impl ClipmapGpu {
    pub fn from_cpu(cpu: &crate::clipmap::ClipmapParamsCpu) -> Self {
        let mut level = [[0.0f32; 4]; crate::config::CLIPMAP_LEVELS_USIZE];

        for i in 0..crate::config::CLIPMAP_LEVELS_USIZE {
            let p = cpu.level[i];
            level[i] = [
                p.origin_x_m,
                p.origin_z_m,
                p.cell_size_m,
                f32::from_bits(p.packed_offsets),
            ];
        }

        Self {
            levels: cpu.levels,
            res: cpu.res,
            base_cell_m: cpu.base_cell_m,
            _pad0: 0.0,
            level,
        }
    }
}

#[repr(C)]
#[derive(Clone, Copy, Pod, Zeroable)]
pub struct OverlayGpu {
    pub fps: u32,
    pub width: u32,
    pub height: u32,
    pub _pad0: u32,
}

// src/render/mod.rs
// -----------------
// src/render/mod.rs

pub mod gpu_types;
pub mod resources;
pub mod shaders;
pub mod state;

pub use gpu_types::*;
pub use state::Renderer;

// src/render/resources.rs
// -----------------------
// src/render/resources.rs
//
// Small GPU resource helpers that don't fit cleanly into the renderer "state" modules.
//
// Right now this file provides the final full-resolution output texture:
// - written as a STORAGE texture by the composite compute pass
// - sampled as a regular texture by the final blit render pass
//
// Keeping this as a tiny helper makes the main texture set code a bit cleaner.

/// Wrapper for the renderer's final output texture view.
///
/// The renderer stores only the TextureView; the view keeps the underlying texture alive
/// for as long as it exists (wgpu uses ref-counted internal ownership).
pub struct OutputTex {
    /// Texture view bound in bind groups (storage write in compute, sampled in blit).
    pub view: wgpu::TextureView,
}

/// Create the final output texture (full resolution).
///
/// Properties:
/// - Format: RGBA16F (high dynamic range, good for post-processing)
/// - Usage:
///   - STORAGE_BINDING: composite pass writes into it as a storage texture
///   - TEXTURE_BINDING: blit pass samples it in the fragment shader
///
/// Notes:
/// - wgpu forbids zero-sized textures, so we clamp `w`/`h` to at least 1.
pub fn create_output_texture(device: &wgpu::Device, w: u32, h: u32) -> OutputTex {
    // Avoid creating zero-sized textures (can happen during minimize/resizes).
    let w = w.max(1);
    let h = h.max(1);

    // Allocate the GPU texture backing store.
    let tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("output_tex"),
        size: wgpu::Extent3d {
            width: w,
            height: h,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format: wgpu::TextureFormat::Rgba16Float,
        // Must support both compute writes and render sampling.
        usage: wgpu::TextureUsages::STORAGE_BINDING | wgpu::TextureUsages::TEXTURE_BINDING,
        view_formats: &[],
    });

    // Default view covers the whole texture.
    let view = tex.create_view(&Default::default());

    OutputTex { view }
}

// src/render/shaders.rs
// ---------------------
// src/render/shaders.rs
//
// Centralized shader sources. WGSL has no native include mechanism in wgpu,
// so we concatenate multiple WGSL files into a single source string.

pub const RAY_CS_WGSL: &str = concat!(
    include_str!("../shaders/common.wgsl"),
    "\n",
    include_str!("../shaders/ray_core.wgsl"),
    "\n",
    include_str!("../shaders/clipmap.wgsl"),
    "\n",
    include_str!("../shaders/ray_main.wgsl"),
    "\n",
);

pub const BLIT_WGSL: &str = include_str!("../shaders/blit.wgsl");

#[inline]
pub fn ray_cs_wgsl() -> &'static str {
    RAY_CS_WGSL
}

#[inline]
pub fn blit_wgsl() -> &'static str {
    BLIT_WGSL
}

// src/render/state/bindgroups.rs
// ------------------------------
// src/render/state/bindgroups.rs
//
// Bind group creation.

use super::{buffers::Buffers, layout::Layouts, textures::TextureSet};

pub struct BindGroups {
    pub primary: wgpu::BindGroup,
    pub scene: wgpu::BindGroup,
    pub godray: [wgpu::BindGroup; 2],
    pub composite: [wgpu::BindGroup; 2],
    pub empty: wgpu::BindGroup,
    pub blit: wgpu::BindGroup,
}

fn make_primary_bg(
    device: &wgpu::Device,
    layout: &wgpu::BindGroupLayout,
    buffers: &Buffers,
    textures: &TextureSet,
) -> wgpu::BindGroup {
    device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("primary_bg"),
        layout,
        entries: &[
            wgpu::BindGroupEntry {
                binding: 0,
                resource: buffers.camera.as_entire_binding(),
            },
            wgpu::BindGroupEntry {
                binding: 1,
                resource: buffers.chunk.as_entire_binding(),
            },
            wgpu::BindGroupEntry {
                binding: 2,
                resource: buffers.node.as_entire_binding(),
            },
            wgpu::BindGroupEntry {
                binding: 3,
                resource: buffers.chunk_grid.as_entire_binding(),
            },
            wgpu::BindGroupEntry {
                binding: 4,
                resource: wgpu::BindingResource::TextureView(&textures.color.view),
            },
            wgpu::BindGroupEntry {
                binding: 5,
                resource: wgpu::BindingResource::TextureView(&textures.depth.view),
            },
            // Clipmap params uniform
            wgpu::BindGroupEntry {
                binding: 6,
                resource: buffers.clipmap.as_entire_binding(),
            },
            // Clipmap height texture array
            wgpu::BindGroupEntry {
                binding: 7,
                resource: wgpu::BindingResource::TextureView(&textures.clip_height.view),
            },
        ],
    })
}

fn make_scene_bg(
    device: &wgpu::Device,
    layout: &wgpu::BindGroupLayout,
    buffers: &Buffers,
) -> wgpu::BindGroup {
    device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("scene_bg"),
        layout,
        entries: &[
            wgpu::BindGroupEntry {
                binding: 0,
                resource: buffers.camera.as_entire_binding(),
            },
            wgpu::BindGroupEntry {
                binding: 1,
                resource: buffers.chunk.as_entire_binding(),
            },
            wgpu::BindGroupEntry {
                binding: 2,
                resource: buffers.node.as_entire_binding(),
            },
            wgpu::BindGroupEntry {
                binding: 3,
                resource: buffers.chunk_grid.as_entire_binding(),
            },
        ],
    })
}

fn make_godray_bg(
    device: &wgpu::Device,
    layout: &wgpu::BindGroupLayout,
    depth_view: &wgpu::TextureView,
    hist_view: &wgpu::TextureView,
    out_view: &wgpu::TextureView,
    label: &str,
) -> wgpu::BindGroup {
    device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some(label),
        layout,
        entries: &[
            wgpu::BindGroupEntry {
                binding: 0,
                resource: wgpu::BindingResource::TextureView(depth_view),
            },
            wgpu::BindGroupEntry {
                binding: 1,
                resource: wgpu::BindingResource::TextureView(hist_view),
            },
            wgpu::BindGroupEntry {
                binding: 2,
                resource: wgpu::BindingResource::TextureView(out_view),
            },
        ],
    })
}

fn make_composite_bg(
    device: &wgpu::Device,
    layout: &wgpu::BindGroupLayout,
    color_view: &wgpu::TextureView,
    godray_view: &wgpu::TextureView,
    output_view: &wgpu::TextureView,
    label: &str,
) -> wgpu::BindGroup {
    device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some(label),
        layout,
        entries: &[
            wgpu::BindGroupEntry {
                binding: 0,
                resource: wgpu::BindingResource::TextureView(color_view),
            },
            wgpu::BindGroupEntry {
                binding: 1,
                resource: wgpu::BindingResource::TextureView(godray_view),
            },
            wgpu::BindGroupEntry {
                binding: 2,
                resource: wgpu::BindingResource::TextureView(output_view),
            },
        ],
    })
}

fn make_blit_bg(
    device: &wgpu::Device,
    layout: &wgpu::BindGroupLayout,
    output_view: &wgpu::TextureView,
    sampler: &wgpu::Sampler,
    overlay_buf: &wgpu::Buffer,
) -> wgpu::BindGroup {
    device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("blit_bg"),
        layout,
        entries: &[
            wgpu::BindGroupEntry {
                binding: 0,
                resource: wgpu::BindingResource::TextureView(output_view),
            },
            wgpu::BindGroupEntry {
                binding: 1,
                resource: wgpu::BindingResource::Sampler(sampler),
            },
            wgpu::BindGroupEntry {
                binding: 2,
                resource: overlay_buf.as_entire_binding(),
            },
        ],
    })
}

pub fn create_bind_groups(
    device: &wgpu::Device,
    layouts: &Layouts,
    buffers: &Buffers,
    textures: &TextureSet,
    sampler: &wgpu::Sampler,
) -> BindGroups {
    let primary = make_primary_bg(device, &layouts.primary, buffers, textures);
    let scene = make_scene_bg(device, &layouts.scene, buffers);

    let empty = device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("empty_bg"),
        layout: &layouts.empty,
        entries: &[],
    });

    let godray = [
        make_godray_bg(
            device,
            &layouts.godray,
            &textures.depth.view,
            &textures.godray[0].view,
            &textures.godray[1].view,
            "godray_bg_a_to_b",
        ),
        make_godray_bg(
            device,
            &layouts.godray,
            &textures.depth.view,
            &textures.godray[1].view,
            &textures.godray[0].view,
            "godray_bg_b_to_a",
        ),
    ];

    let composite = [
        make_composite_bg(
            device,
            &layouts.composite,
            &textures.color.view,
            &textures.godray[0].view,
            &textures.output.view,
            "composite_bg_read_a",
        ),
        make_composite_bg(
            device,
            &layouts.composite,
            &textures.color.view,
            &textures.godray[1].view,
            &textures.output.view,
            "composite_bg_read_b",
        ),
    ];

    let blit = make_blit_bg(
        device,
        &layouts.blit,
        &textures.output.view,
        sampler,
        &buffers.overlay,
    );

    BindGroups {
        primary,
        scene,
        godray,
        composite,
        empty,
        blit,
    }
}

// src/render/state/buffers.rs
// ---------------------------
// src/render/state/buffers.rs
//
// Persistent GPU buffers and capacities.

use crate::{
    config,
    render::gpu_types::{ChunkMetaGpu, ClipmapGpu, NodeGpu},
};

pub struct Buffers {
    // --- Uniforms ---
    pub camera: wgpu::Buffer,
    pub overlay: wgpu::Buffer,

    /// Clipmap params (primary compute pass only).
    pub clipmap: wgpu::Buffer,

    // --- Storage buffers ---
    pub node: wgpu::Buffer,
    pub chunk: wgpu::Buffer,
    pub chunk_grid: wgpu::Buffer,

    // --- Capacities ---
    pub node_capacity: u32,
    pub chunk_capacity: u32,
    pub grid_capacity: u32,
}

fn make_uniform_buffer<T: Sized>(device: &wgpu::Device, label: &str) -> wgpu::Buffer {
    device.create_buffer(&wgpu::BufferDescriptor {
        label: Some(label),
        size: std::mem::size_of::<T>() as u64,
        usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        mapped_at_creation: false,
    })
}

fn make_storage_buffer(device: &wgpu::Device, label: &str, size_bytes: u64) -> wgpu::Buffer {
    device.create_buffer(&wgpu::BufferDescriptor {
        label: Some(label),
        size: size_bytes,
        usage: wgpu::BufferUsages::STORAGE | wgpu::BufferUsages::COPY_DST,
        mapped_at_creation: false,
    })
}

pub fn create_persistent_buffers(device: &wgpu::Device) -> Buffers {
    let camera = make_uniform_buffer::<crate::render::gpu_types::CameraGpu>(device, "camera_buf");
    let overlay = make_uniform_buffer::<crate::render::gpu_types::OverlayGpu>(device, "overlay_buf");

    let clipmap = make_uniform_buffer::<ClipmapGpu>(device, "clipmap_buf");

    let node_capacity = (config::NODE_BUDGET_BYTES / std::mem::size_of::<NodeGpu>()) as u32;

    let node = make_storage_buffer(
        device,
        "svo_nodes_arena",
        (node_capacity as u64) * (std::mem::size_of::<NodeGpu>() as u64),
    );

    let chunk_capacity =
        (2 * config::KEEP_RADIUS + 1) as u32 * 4u32 * (2 * config::KEEP_RADIUS + 1) as u32;

    let chunk = make_storage_buffer(
        device,
        "chunk_meta_persistent",
        (chunk_capacity as u64) * (std::mem::size_of::<ChunkMetaGpu>() as u64),
    );

    let grid_capacity = chunk_capacity;

    let chunk_grid = make_storage_buffer(
        device,
        "chunk_grid_buf",
        (grid_capacity as u64) * (std::mem::size_of::<u32>() as u64),
    );

    Buffers {
        camera,
        overlay,
        clipmap,
        node,
        chunk,
        chunk_grid,
        node_capacity,
        chunk_capacity,
        grid_capacity,
    }
}

// src/render/state/layout.rs
// --------------------------
// src/render/state/layout.rs
//
// Bind group layouts and small helpers.

pub struct Layouts {
    pub primary: wgpu::BindGroupLayout,
    pub scene: wgpu::BindGroupLayout,
    pub godray: wgpu::BindGroupLayout,
    pub composite: wgpu::BindGroupLayout,
    pub empty: wgpu::BindGroupLayout,
    pub blit: wgpu::BindGroupLayout,
}

fn bgl_uniform(binding: u32, visibility: wgpu::ShaderStages) -> wgpu::BindGroupLayoutEntry {
    wgpu::BindGroupLayoutEntry {
        binding,
        visibility,
        ty: wgpu::BindingType::Buffer {
            ty: wgpu::BufferBindingType::Uniform,
            has_dynamic_offset: false,
            min_binding_size: None,
        },
        count: None,
    }
}

fn bgl_storage_ro(binding: u32, visibility: wgpu::ShaderStages) -> wgpu::BindGroupLayoutEntry {
    wgpu::BindGroupLayoutEntry {
        binding,
        visibility,
        ty: wgpu::BindingType::Buffer {
            ty: wgpu::BufferBindingType::Storage { read_only: true },
            has_dynamic_offset: false,
            min_binding_size: None,
        },
        count: None,
    }
}

fn bgl_tex_sample_2d(
    binding: u32,
    visibility: wgpu::ShaderStages,
    sample_type: wgpu::TextureSampleType,
) -> wgpu::BindGroupLayoutEntry {
    wgpu::BindGroupLayoutEntry {
        binding,
        visibility,
        ty: wgpu::BindingType::Texture {
            sample_type,
            view_dimension: wgpu::TextureViewDimension::D2,
            multisampled: false,
        },
        count: None,
    }
}

fn bgl_tex_sample_2d_array(
    binding: u32,
    visibility: wgpu::ShaderStages,
    sample_type: wgpu::TextureSampleType,
) -> wgpu::BindGroupLayoutEntry {
    wgpu::BindGroupLayoutEntry {
        binding,
        visibility,
        ty: wgpu::BindingType::Texture {
            sample_type,
            view_dimension: wgpu::TextureViewDimension::D2Array,
            multisampled: false,
        },
        count: None,
    }
}

fn bgl_storage_tex_wo(
    binding: u32,
    visibility: wgpu::ShaderStages,
    format: wgpu::TextureFormat,
) -> wgpu::BindGroupLayoutEntry {
    wgpu::BindGroupLayoutEntry {
        binding,
        visibility,
        ty: wgpu::BindingType::StorageTexture {
            access: wgpu::StorageTextureAccess::WriteOnly,
            format,
            view_dimension: wgpu::TextureViewDimension::D2,
        },
        count: None,
    }
}

pub fn create_layouts(device: &wgpu::Device) -> Layouts {
    let cs_vis = wgpu::ShaderStages::COMPUTE;

    let scene_entries: [wgpu::BindGroupLayoutEntry; 4] = [
        bgl_uniform(0, cs_vis),
        bgl_storage_ro(1, cs_vis),
        bgl_storage_ro(2, cs_vis),
        bgl_storage_ro(3, cs_vis),
    ];

    let scene = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("scene_bgl"),
        entries: &scene_entries,
    });

    // PRIMARY: add clipmap uniform + clipmap height texture array
    // bindings:
    // 0 camera
    // 1 chunks
    // 2 nodes
    // 3 chunk_grid
    // 4 color storage
    // 5 depth storage
    // 6 clipmap uniform
    // 7 clipmap height texture array (R32Float)
    let mut primary_entries = Vec::with_capacity(8);
    primary_entries.extend_from_slice(&scene_entries);

    primary_entries.push(bgl_storage_tex_wo(4, cs_vis, wgpu::TextureFormat::Rgba16Float));
    primary_entries.push(bgl_storage_tex_wo(5, cs_vis, wgpu::TextureFormat::R32Float));

    primary_entries.push(bgl_uniform(6, cs_vis));
    primary_entries.push(bgl_tex_sample_2d_array(
        7,
        cs_vis,
        wgpu::TextureSampleType::Float { filterable: false },
    ));

    let primary = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("primary_bgl"),
        entries: &primary_entries,
    });

    let godray = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("godray_bgl"),
        entries: &[
            bgl_tex_sample_2d(
                0,
                cs_vis,
                wgpu::TextureSampleType::Float { filterable: false },
            ),
            bgl_tex_sample_2d(
                1,
                cs_vis,
                wgpu::TextureSampleType::Float { filterable: false },
            ),
            bgl_storage_tex_wo(2, cs_vis, wgpu::TextureFormat::Rgba16Float),
        ],
    });

    let composite = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("composite_bgl"),
        entries: &[
            bgl_tex_sample_2d(
                0,
                cs_vis,
                wgpu::TextureSampleType::Float { filterable: false },
            ),
            bgl_tex_sample_2d(
                1,
                cs_vis,
                wgpu::TextureSampleType::Float { filterable: false },
            ),
            bgl_storage_tex_wo(2, cs_vis, wgpu::TextureFormat::Rgba16Float),
        ],
    });

    let empty = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("empty_bgl"),
        entries: &[],
    });

    let blit = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("blit_bgl"),
        entries: &[
            bgl_tex_sample_2d(
                0,
                wgpu::ShaderStages::FRAGMENT,
                wgpu::TextureSampleType::Float { filterable: true },
            ),
            wgpu::BindGroupLayoutEntry {
                binding: 1,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                count: None,
            },
            bgl_uniform(2, wgpu::ShaderStages::FRAGMENT),
        ],
    });

    Layouts {
        primary,
        scene,
        godray,
        composite,
        empty,
        blit,
    }
}

// src/render/state/mod.rs
// -----------------------
// src/render/state/mod.rs
// -----------------------
mod bindgroups;
mod buffers;
mod layout;
mod pipelines;
pub mod textures;

use crate::{
    config,
    render::gpu_types::{CameraGpu, ClipmapGpu, OverlayGpu},
    streaming::ChunkUpload,
};

use bindgroups::{create_bind_groups, BindGroups};
use buffers::{create_persistent_buffers, Buffers};
use layout::{create_layouts, Layouts};
use pipelines::{create_pipelines, Pipelines};
use textures::{create_textures, quarter_dim, TextureSet};

pub struct Renderer {
    device: wgpu::Device,
    queue: wgpu::Queue,

    sampler: wgpu::Sampler,

    layouts: Layouts,
    pipelines: Pipelines,
    buffers: Buffers,
    textures: TextureSet,
    bind_groups: BindGroups,

    ping: usize,
}

impl Renderer {
    pub async fn new(
        adapter: &wgpu::Adapter,
        surface_format: wgpu::TextureFormat,
        width: u32,
        height: u32,
    ) -> Self {
        let adapter_limits = adapter.limits();
        let required_limits = wgpu::Limits {
            max_storage_buffer_binding_size: adapter_limits.max_storage_buffer_binding_size,
            max_buffer_size: adapter_limits.max_buffer_size,
            ..wgpu::Limits::default()
        };

        let (device, queue) = adapter
            .request_device(
                &wgpu::DeviceDescriptor {
                    label: Some("device"),
                    required_features: wgpu::Features::empty(),
                    required_limits,
                },
                None,
            )
            .await
            .unwrap();

        let cs_module = device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("ray_cs"),
            source: wgpu::ShaderSource::Wgsl(crate::render::shaders::ray_cs_wgsl().into()),
        });

        let fs_module = device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("blit"),
            source: wgpu::ShaderSource::Wgsl(crate::render::shaders::blit_wgsl().into()),
        });

        let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
            label: Some("nearest_sampler"),
            mag_filter: wgpu::FilterMode::Nearest,
            min_filter: wgpu::FilterMode::Nearest,
            mipmap_filter: wgpu::FilterMode::Nearest,
            ..Default::default()
        });

        let layouts = create_layouts(&device);
        let buffers = create_persistent_buffers(&device);

        let textures = create_textures(&device, width, height);

        let pipelines = create_pipelines(&device, &layouts, &cs_module, &fs_module, surface_format);

        let bind_groups = create_bind_groups(&device, &layouts, &buffers, &textures, &sampler);

        Self {
            device,
            queue,
            sampler,
            layouts,
            pipelines,
            buffers,
            textures,
            bind_groups,
            ping: 0,
        }
    }

    pub fn device(&self) -> &wgpu::Device {
        &self.device
    }

    pub fn queue(&self) -> &wgpu::Queue {
        &self.queue
    }

    pub fn resize_output(&mut self, width: u32, height: u32) {
        self.textures = create_textures(&self.device, width, height);
        self.bind_groups = create_bind_groups(
            &self.device,
            &self.layouts,
            &self.buffers,
            &self.textures,
            &self.sampler,
        );

        self.ping = 0;
    }

    pub fn write_chunk_grid(&self, grid: &[u32]) {
        let n = grid.len().min(self.buffers.grid_capacity as usize);
        self.queue.write_buffer(
            &self.buffers.chunk_grid,
            0,
            bytemuck::cast_slice(&grid[..n]),
        );
    }

    pub fn write_camera(&self, cam: &CameraGpu) {
        self.queue
            .write_buffer(&self.buffers.camera, 0, bytemuck::bytes_of(cam));
    }

    pub fn write_overlay(&self, ov: &OverlayGpu) {
        self.queue
            .write_buffer(&self.buffers.overlay, 0, bytemuck::bytes_of(ov));
    }

    pub fn write_clipmap(&self, clip: &ClipmapGpu) {
        self.queue
            .write_buffer(&self.buffers.clipmap, 0, bytemuck::bytes_of(clip));
    }

    /// FP16 clipmap patch upload into a sub-rectangle of a level.
    ///
    /// `data_f16` is w*h u16 values (IEEE half bits), row-major for the patch.
    ///
    /// IMPORTANT: WebGPU requires `bytes_per_row` to be a multiple of 256 bytes.
    /// For narrow strips (especially columns), we pad each row on the CPU when needed.
    pub fn write_clipmap_patch(&self, level: u32, x: u32, y: u32, w: u32, h: u32, data_f16: &[u16]) {
        let res = config::CLIPMAP_RES;
        if level >= config::CLIPMAP_LEVELS {
            return;
        }
        if w == 0 || h == 0 {
            return;
        }
        if x + w > res || y + h > res {
            return;
        }

        let expected = (w as usize) * (h as usize);
        if data_f16.len() != expected {
            return;
        }

        // Source row pitch (tightly packed)
        let row_bytes = (w * 2) as usize; // R16Float => 2 bytes per texel

        // WebGPU alignment requirement
        let align = 256usize;
        let padded_row_bytes = ((row_bytes + align - 1) / align) * align;

        let bytes: Vec<u8>;
        let bytes_ref: &[u8];

        if padded_row_bytes == row_bytes {
            bytes_ref = bytemuck::cast_slice(data_f16);
        } else {
            // Pad each row up to padded_row_bytes
            bytes = {
                let mut out = vec![0u8; padded_row_bytes * (h as usize)];
                let src: &[u8] = bytemuck::cast_slice(data_f16);

                for row in 0..(h as usize) {
                    let src_off = row * row_bytes;
                    let dst_off = row * padded_row_bytes;
                    out[dst_off..dst_off + row_bytes].copy_from_slice(&src[src_off..src_off + row_bytes]);
                }
                out
            };
            bytes_ref = &bytes;
        }

        self.queue.write_texture(
            wgpu::ImageCopyTexture {
                texture: &self.textures.clip_height.tex,
                mip_level: 0,
                origin: wgpu::Origin3d { x, y, z: level },
                aspect: wgpu::TextureAspect::All,
            },
            bytes_ref,
            wgpu::ImageDataLayout {
                offset: 0,
                bytes_per_row: Some(padded_row_bytes as u32),
                rows_per_image: Some(h),
            },
            wgpu::Extent3d {
                width: w,
                height: h,
                depth_or_array_layers: 1,
            },
        );
    }

    /// Convenience full-level upload (kept for compatibility / debugging).
    pub fn write_clipmap_level(&self, level: u32, data_f16: &[u16]) {
        let res = config::CLIPMAP_RES as usize;
        let expected = res * res;
        if data_f16.len() != expected {
            return;
        }
        self.write_clipmap_patch(
            level,
            0,
            0,
            config::CLIPMAP_RES,
            config::CLIPMAP_RES,
            data_f16,
        );
    }

    pub fn apply_chunk_uploads(&self, uploads: Vec<ChunkUpload>) {
        let node_stride = std::mem::size_of::<crate::render::gpu_types::NodeGpu>() as u64;
        let meta_stride = std::mem::size_of::<crate::render::gpu_types::ChunkMetaGpu>() as u64;

        for u in uploads {
            if u.slot < self.buffers.chunk_capacity {
                let meta_off = (u.slot as u64) * meta_stride;
                self.queue
                    .write_buffer(&self.buffers.chunk, meta_off, bytemuck::bytes_of(&u.meta));
            }

            if !u.nodes.is_empty() {
                let needed = u.nodes.len() as u32;

                if u.node_base <= self.buffers.node_capacity
                    && u.node_base + needed <= self.buffers.node_capacity
                {
                    let node_off = (u.node_base as u64) * node_stride;
                    self.queue.write_buffer(
                        &self.buffers.node,
                        node_off,
                        bytemuck::cast_slice(u.nodes.as_ref()),
                    );
                }
            }
        }
    }

    pub fn encode_compute(&mut self, encoder: &mut wgpu::CommandEncoder, width: u32, height: u32) {
        {
            let mut cpass = encoder.begin_compute_pass(&wgpu::ComputePassDescriptor {
                label: Some("primary_pass"),
                timestamp_writes: None,
            });

            cpass.set_pipeline(&self.pipelines.primary);
            cpass.set_bind_group(0, &self.bind_groups.primary, &[]);

            let gx = (width + 7) / 8;
            let gy = (height + 7) / 8;
            cpass.dispatch_workgroups(gx, gy, 1);
        }

        let ping = self.ping;
        let pong = 1 - ping;

        {
            let qw = quarter_dim(width);
            let qh = quarter_dim(height);

            let mut cpass = encoder.begin_compute_pass(&wgpu::ComputePassDescriptor {
                label: Some("godray_pass"),
                timestamp_writes: None,
            });

            cpass.set_pipeline(&self.pipelines.godray);
            cpass.set_bind_group(0, &self.bind_groups.scene, &[]);
            cpass.set_bind_group(1, &self.bind_groups.godray[ping], &[]);

            let gx = (qw + 7) / 8;
            let gy = (qh + 7) / 8;
            cpass.dispatch_workgroups(gx, gy, 1);
        }

        {
            let mut cpass = encoder.begin_compute_pass(&wgpu::ComputePassDescriptor {
                label: Some("composite_pass"),
                timestamp_writes: None,
            });

            cpass.set_pipeline(&self.pipelines.composite);

            cpass.set_bind_group(0, &self.bind_groups.empty, &[]);
            cpass.set_bind_group(1, &self.bind_groups.empty, &[]);
            cpass.set_bind_group(2, &self.bind_groups.composite[pong], &[]);

            let gx = (width + 7) / 8;
            let gy = (height + 7) / 8;
            cpass.dispatch_workgroups(gx, gy, 1);
        }

        self.ping = pong;
    }

    pub fn encode_blit(&self, encoder: &mut wgpu::CommandEncoder, frame_view: &wgpu::TextureView) {
        let mut rpass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
            label: Some("blit_pass"),
            color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                view: frame_view,
                resolve_target: None,
                ops: wgpu::Operations {
                    load: wgpu::LoadOp::Clear(wgpu::Color::BLACK),
                    store: wgpu::StoreOp::Store,
                },
            })],
            depth_stencil_attachment: None,
            timestamp_writes: None,
            occlusion_query_set: None,
        });

        rpass.set_pipeline(&self.pipelines.blit);
        rpass.set_bind_group(0, &self.bind_groups.blit, &[]);
        rpass.draw(0..3, 0..1);
    }
}

// src/render/state/pipelines.rs
// -----------------------------
// src/render/state/pipelines.rs
//
// Pipeline creation.
// This is intentionally isolated so the renderer logic (per-frame encoding) isn't
// buried under wgpu setup boilerplate.
//
// Terminology:
// - BindGroupLayout (BGL): describes what resources exist at @group/@binding.
// - PipelineLayout (PL): ordered list of BGLs for group(0), group(1), ...
// - Pipeline: compiled/validated shader entry point + fixed state + pipeline layout.
//
// Rule of thumb:
// The order of BGLs in `bind_group_layouts` must match the group indices used in WGSL.
// If a shader references @group(2), then the pipeline layout must include entries
// for group(0) and group(1) as well (even if they're "empty" placeholders).

use super::layout::Layouts;

pub struct Pipelines {
    /// Compute pipeline for the primary full-resolution pass (writes color/depth).
    pub primary: wgpu::ComputePipeline,

    /// Compute pipeline for the quarter-resolution godray pass (ping-pong temporal).
    pub godray: wgpu::ComputePipeline,

    /// Compute pipeline for the full-resolution composite pass (writes final output).
    pub composite: wgpu::ComputePipeline,

    /// Render pipeline for the final blit to the swapchain (fullscreen triangle).
    pub blit: wgpu::RenderPipeline,
}

/// Helper to build a compute pipeline with a specific entry point and bind group layout list.
///
/// `bgls` order defines the pipeline layout's group indices:
/// - bgls[0] => group(0)
/// - bgls[1] => group(1)
/// - ...
fn make_compute_pipeline(
    device: &wgpu::Device,
    label: &str,
    module: &wgpu::ShaderModule,
    entry: &str,
    bgls: &[&wgpu::BindGroupLayout],
) -> wgpu::ComputePipeline {
    // Create a pipeline layout named "{label}_pl" that fixes the bind group schema.
    let pl = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: Some(&format!("{label}_pl")),
        bind_group_layouts: bgls,
        // No push constants used by these shaders.
        push_constant_ranges: &[],
    });

    // Create the compute pipeline referencing the WGSL entry point.
    device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
        label: Some(label),
        layout: Some(&pl),
        module,
        entry_point: entry,
        compilation_options: Default::default(),
    })
}

/// Create all pipelines (compute + blit).
///
/// Inputs:
/// - `cs_module`: WGSL module containing compute entry points.
/// - `fs_module`: WGSL module containing vertex/fragment entry points for blit.
/// - `surface_format`: swapchain format used for the final render target.
pub fn create_pipelines(
    device: &wgpu::Device,
    layouts: &Layouts,
    cs_module: &wgpu::ShaderModule,
    fs_module: &wgpu::ShaderModule,
    surface_format: wgpu::TextureFormat,
) -> Pipelines {
    // -------------------------------------------------------------------------
    // Compute pipelines
    // -------------------------------------------------------------------------

    // Primary pass:
    // Uses group(0) = layouts.primary, which includes:
    // - camera + scene buffers
    // - storage outputs for color/depth
    let primary = make_compute_pipeline(
        device,
        "primary_pipeline",
        cs_module,
        "main_primary",
        &[&layouts.primary],
    );

    // Godray pass:
    // Uses:
    //   group(0) = layouts.scene  (camera + scene buffers only)
    //   group(1) = layouts.godray (depth sample + history sample + out storage)
    let godray = make_compute_pipeline(
        device,
        "godray_pipeline",
        cs_module,
        "main_godray",
        &[&layouts.scene, &layouts.godray],
    );

    // Composite pass:
    // Shader reads from @group(2) (color + godray + output storage).
    // wgpu requires the pipeline layout to include group(0) and group(1) slots too,
    // so we provide empty placeholder layouts for those indices.
    let composite = make_compute_pipeline(
        device,
        "composite_pipeline",
        cs_module,
        "main_composite",
        &[&layouts.empty, &layouts.empty, &layouts.composite],
    );

    // -------------------------------------------------------------------------
    // Render pipeline: blit
    // -------------------------------------------------------------------------
    //
    // Full-screen triangle approach:
    // - No vertex buffers.
    // - Vertex shader generates positions from vertex_index.
    // - Fragment shader samples the renderer output texture.

    // Pipeline layout for blit uses a single bind group: group(0) = layouts.blit.
    let blit_pl = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: Some("blit_pl"),
        bind_group_layouts: &[&layouts.blit],
        push_constant_ranges: &[],
    });

    // Render pipeline state:
    // - Targets the swapchain format.
    // - Uses REPLACE blending (overwrite framebuffer).
    // - Default primitive/multisample state is fine for a simple fullscreen draw.
    let blit = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
        label: Some("blit_pipeline"),
        layout: Some(&blit_pl),
        vertex: wgpu::VertexState {
            module: fs_module,
            entry_point: "vs_main",
            // No vertex buffers; vertices are synthesized in the vertex shader.
            buffers: &[],
            compilation_options: Default::default(),
        },
        fragment: Some(wgpu::FragmentState {
            module: fs_module,
            entry_point: "fs_main",
            targets: &[Some(wgpu::ColorTargetState {
                format: surface_format,
                // Overwrite swapchain pixel with sampled color.
                blend: Some(wgpu::BlendState::REPLACE),
                write_mask: wgpu::ColorWrites::ALL,
            })],
            compilation_options: Default::default(),
        }),
        // Default triangle list, CCW front face, etc. (fullscreen triangle doesn't care much).
        primitive: wgpu::PrimitiveState::default(),
        depth_stencil: None,
        multisample: wgpu::MultisampleState::default(),
        multiview: None,
    });

    Pipelines {
        primary,
        godray,
        composite,
        blit,
    }
}

// src/render/state/textures.rs
// ----------------------------
// src/render/state/textures.rs
// ----------------------------

use crate::{
    config,
    render::resources::{create_output_texture, OutputTex},
};

pub struct Tex2D {
    pub view: wgpu::TextureView,
}

pub struct Tex2DArray {
    pub tex: wgpu::Texture,
    pub view: wgpu::TextureView,
}

pub struct TextureSet {
    pub output: OutputTex,
    pub color: Tex2D,
    pub depth: Tex2D,
    pub godray: [Tex2D; 2],

    pub clip_height: Tex2DArray,
}

pub fn quarter_dim(x: u32) -> u32 {
    (x + 3) / 4
}

fn make_tex2d(
    device: &wgpu::Device,
    label: &str,
    w: u32,
    h: u32,
    format: wgpu::TextureFormat,
    usage: wgpu::TextureUsages,
) -> Tex2D {
    let w = w.max(1);
    let h = h.max(1);

    let tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some(label),
        size: wgpu::Extent3d {
            width: w,
            height: h,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format,
        usage,
        view_formats: &[],
    });

    let view = tex.create_view(&Default::default());
    Tex2D { view }
}

fn make_tex2d_array(
    device: &wgpu::Device,
    label: &str,
    w: u32,
    h: u32,
    layers: u32,
    format: wgpu::TextureFormat,
    usage: wgpu::TextureUsages,
) -> Tex2DArray {
    let w = w.max(1);
    let h = h.max(1);
    let layers = layers.max(1);

    let tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some(label),
        size: wgpu::Extent3d {
            width: w,
            height: h,
            depth_or_array_layers: layers,
        },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format,
        usage,
        view_formats: &[],
    });

    let view = tex.create_view(&wgpu::TextureViewDescriptor {
        label: Some(&format!("{label}_view")),
        format: Some(format),
        dimension: Some(wgpu::TextureViewDimension::D2Array),
        aspect: wgpu::TextureAspect::All,
        base_mip_level: 0,
        mip_level_count: Some(1),
        base_array_layer: 0,
        array_layer_count: Some(layers),
    });

    Tex2DArray { tex, view }
}

pub fn create_textures(device: &wgpu::Device, width: u32, height: u32) -> TextureSet {
    let width = width.max(1);
    let height = height.max(1);

    let rw_tex_usage =
        wgpu::TextureUsages::STORAGE_BINDING | wgpu::TextureUsages::TEXTURE_BINDING;

    let output = create_output_texture(device, width, height);

    let color = make_tex2d(
        device,
        "color_tex",
        width,
        height,
        wgpu::TextureFormat::Rgba16Float,
        rw_tex_usage,
    );

    let depth = make_tex2d(
        device,
        "depth_tex",
        width,
        height,
        wgpu::TextureFormat::R32Float,
        rw_tex_usage,
    );

    let qw = quarter_dim(width);
    let qh = quarter_dim(height);

    let godray = [
        make_tex2d(
            device,
            "godray_a",
            qw,
            qh,
            wgpu::TextureFormat::Rgba16Float,
            rw_tex_usage,
        ),
        make_tex2d(
            device,
            "godray_b",
            qw,
            qh,
            wgpu::TextureFormat::Rgba16Float,
            rw_tex_usage,
        ),
    ];

    // FP16 clipmap height: R16Float (half bandwidth vs R32Float)
    let clip_height = make_tex2d_array(
        device,
        "clip_height",
        config::CLIPMAP_RES,
        config::CLIPMAP_RES,
        config::CLIPMAP_LEVELS,
        wgpu::TextureFormat::R16Float,
        wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
    );

    TextureSet {
        output,
        color,
        depth,
        godray,
        clip_height,
    }
}

// src/shaders/blit.wgsl
// ---------------------
// blit.wgsl
//
// Minimal fullscreen blit + tiny HUD:
//
// 1) Vertex shader emits a single fullscreen triangle (no vertex buffers).
//    This is a common trick to avoid cracks/precision issues on a fullscreen quad.
// 2) Fragment shader:
//    - samples the HDR-ish compute output texture
//    - applies a simple tonemap-like curve: c / (c + 1)
//    - optionally draws a tiny 3x5-pixel-font FPS overlay in the top-right.
//
// Bindings (must match Rust bind group layout `layouts.blit`):
//   @group(0) @binding(0): sampled output texture (img)
//   @group(0) @binding(1): sampler (samp)
//   @group(0) @binding(2): uniform overlay struct (fps + dimensions)

@group(0) @binding(0) var img : texture_2d<f32>;
@group(0) @binding(1) var samp : sampler;

// Overlay uniform block written from CPU each frame (or periodically for fps).
// `width/height` are used to place the overlay in screen space.
// `_pad0` keeps the struct 16-byte aligned (nice for uniform layout rules).
struct Overlay {
  fps    : u32,
  width  : u32,
  height : u32,
  _pad0  : u32,
};
@group(0) @binding(2) var<uniform> overlay : Overlay;


// -----------------------------------------------------------------------------
// 3x5 digit font helpers
// -----------------------------------------------------------------------------
//
// Digits are encoded as a 3x5 bitmap packed into 15 bits, row-major:
//   bit = y*3 + x
// with (x,y) = (0,0) being the top-left pixel of the digit cell.
//
// Example for "0":
//   111
//   101
//   101
//   101
//   111
//
// The returned constants are the 15-bit masks for digits 0..9.

fn digit_mask(d: u32) -> u32 {
  // 3x5 digits packed into 15 bits (row-major), bit0 = top-left.
  if (d == 0u) { return 0x7B6Fu; } // 111 101 101 101 111
  if (d == 1u) { return 0x749Au; } // 010 110 010 010 111
  if (d == 2u) { return 0x73E7u; } // 111 001 111 100 111
  if (d == 3u) { return 0x79E7u; } // 111 001 111 001 111
  if (d == 4u) { return 0x49EDu; } // 101 101 111 001 001
  if (d == 5u) { return 0x79CFu; } // 111 100 111 001 111
  if (d == 6u) { return 0x7BCFu; } // 111 100 111 101 111
  if (d == 7u) { return 0x4927u; } // 111 001 001 001 001
  if (d == 8u) { return 0x7BEFu; } // 111 101 111 101 111
  if (d == 9u) { return 0x79EFu; } // 111 101 111 001 111
  return 0u;
}

// Return true if the digit mask has a "pixel on" at (x,y) in a 3x5 grid.
fn mask_bit(mask: u32, x: u32, y: u32) -> bool {
  // x in [0..2], y in [0..4]
  let bit = y * 3u + x;
  return ((mask >> bit) & 1u) != 0u;
}


// -----------------------------------------------------------------------------
// Fullscreen triangle vertex shader
// -----------------------------------------------------------------------------
//
// Output:
// - @builtin(position): clip-space position
// - @location(0): UV in [0..1] (with overshoot values on the other two verts)
//   that interpolates correctly across the fullscreen triangle.

struct VSOut {
  @builtin(position) pos: vec4<f32>,
  @location(0) uv: vec2<f32>,
};

@vertex
fn vs_main(@builtin(vertex_index) i: u32) -> VSOut {
  // Fullscreen triangle in clip space.
  //
  // (-1,-1) is bottom-left, (3,-1) and (-1,3) extend beyond the screen so the
  // triangle fully covers the viewport after clipping.
  var p = array<vec2<f32>, 3>(
    vec2<f32>(-1.0, -1.0),
    vec2<f32>( 3.0, -1.0),
    vec2<f32>(-1.0,  3.0)
  );

  // UVs chosen so the interpolated UV lands in [0..1] over the visible region.
  // This avoids needing a quad/indices/vertex buffer.
  var uv = array<vec2<f32>, 3>(
    vec2<f32>(0.0, 1.0),
    vec2<f32>(2.0, 1.0),
    vec2<f32>(0.0, -1.0)
  );

  var o: VSOut;
  o.pos = vec4<f32>(p[i], 0.0, 1.0);
  o.uv = uv[i];
  return o;
}


// -----------------------------------------------------------------------------
// Fragment shader: sample + tonemap + FPS overlay
// -----------------------------------------------------------------------------

@fragment
fn fs_main(@builtin(position) frag_pos: vec4<f32>, @location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {

  // Sample the renderer's final output texture.
  let c = textureSample(img, samp, uv);

  // Simple tonemap-ish curve:
  // - keeps values in [0..1)
  // - preserves highlight detail somewhat for HDR-ish inputs
  var rgb = c.rgb / (c.rgb + vec3<f32>(1.0));

  // ---- FPS overlay (top-right) ----
  //
  // The overlay draws up to 4 digits (clamped to 9999) using the 3x5 font,
  // scaled by `scale`, with a small margin from the top-right corner.
  //
  // Coordinate note:
  // `@builtin(position) frag_pos` is in framebuffer pixel coordinates.
  // This code treats (0,0) as the *top-left* for overlay placement by using
  // the provided overlay.height/width and direct pixel comparisons.

  // Screen size passed from CPU.
  let dims = vec2<u32>(overlay.width, overlay.height);

  // Current fragment coordinates as integer pixels.
  let px = vec2<u32>(u32(frag_pos.x), u32(frag_pos.y));

  // Layout parameters (edit to taste)
  let scale: u32 = 8u;     // size multiplier for each font pixel
  let digit_w: u32 = 3u * scale;
  let digit_h: u32 = 5u * scale;
  let gap: u32 = 1u * scale;
  let margin: u32 = 12u;

  // We always reserve 4 digits worth of space (right-aligned by placement).
  let num_digits: u32 = 4u;
  let total_w: u32 = num_digits * digit_w + (num_digits - 1u) * gap;

  // Compute overlay origin in signed integer space first to avoid u32 underflow.
  // This allows small windows where (dims.x - margin - total_w) would go negative.
  let ox_i: i32 = i32(dims.x) - i32(margin) - i32(total_w);
  let oy_i: i32 = i32(margin);

  // Clamp origin to >= 0 to keep comparisons valid.
  let origin_x: u32 = u32(max(ox_i, 0));
  let origin_y: u32 = u32(max(oy_i, 0));

  // Extract 4 digits from FPS (clamp to 0..9999).
  // d0 is ones, d3 is thousands.
  var v: u32 = min(overlay.fps, 9999u);
  let d0: u32 = v % 10u; v = v / 10u;
  let d1: u32 = v % 10u; v = v / 10u;
  let d2: u32 = v % 10u; v = v / 10u;
  let d3: u32 = v % 10u;

  // Overlay bounds test: only do digit math if we're inside the overlay rectangle.
  if (px.x >= origin_x && px.x < origin_x + total_w && px.y >= origin_y && px.y < origin_y + digit_h) {
    // Local pixel coords relative to the overlay origin.
    let local_x = px.x - origin_x;
    let local_y = px.y - origin_y;

    // Each digit occupies digit_w, followed by gap (except after last digit).
    let stride = digit_w + gap;

    // Which digit column is this pixel in? (0 = leftmost).
    let digit_i = local_x / stride;

    // Position within the digit+gap region.
    let in_digit_x = local_x % stride;

    // If we're in the gap column area, do nothing (leave underlying rgb).
    if (in_digit_x < digit_w) {
      // Map pixel coords into the 3x5 cell coordinates.
      let cell_x = (in_digit_x / scale); // 0..2
      let cell_y = (local_y / scale);    // 0..4

      // Choose the digit value for this column.
      // digit_i = 0 is leftmost, so we use d3..d0 to display thousands..ones.
      var dig: u32 = 0u;
      if (digit_i == 0u) { dig = d3; }
      if (digit_i == 1u) { dig = d2; }
      if (digit_i == 2u) { dig = d1; }
      if (digit_i == 3u) { dig = d0; }

      // If the corresponding font bit is set, paint the pixel white.
      let m = digit_mask(dig);
      if (mask_bit(m, cell_x, cell_y)) {
        rgb = vec3<f32>(1.0, 1.0, 1.0);
      }
    }
  }

  // Opaque output.
  return vec4<f32>(rgb, 1.0);
}

// src/shaders/clipmap.wgsl
// ------------------------
// src/shaders/clipmap.wgsl
// ------------------------
//
// UPDATED for toroidal (ring) clipmap storage.
// level[i].w stores packed offsets (u16 off_x | (u16 off_z << 16)) via f32 bits.
// We compute inv_cell = 1.0 / cell in shader (since CPU still keeps inv too).

const CLIP_LEVELS_MAX : u32 = 8u;

// March tuning
const HF_MAX_STEPS : u32 = 80u;
const HF_BISECT    : u32 = 6u;

// dt clamp (meters along ray)
const HF_DT_MIN : f32 = 1.00;
const HF_DT_MAX : f32 = 48.0;

struct ClipmapParams {
  levels      : u32,
  res         : u32,
  base_cell_m : f32,
  _pad0       : f32,
  // x=origin_x_m, y=origin_z_m, z=cell_size_m, w=packed offsets bits (off_x/off_z)
  level       : array<vec4<f32>, 5>,
};

@group(0) @binding(6) var<uniform> clip : ClipmapParams;
@group(0) @binding(7) var clip_height : texture_2d_array<f32>;

fn imod(a: i32, m: i32) -> i32 {
  var r = a % m;
  if (r < 0) { r = r + m; }
  return r;
}

fn clip_unpack_offsets(level: u32) -> vec2<i32> {
  let bits: u32 = bitcast<u32>(clip.level[level].w);
  let off_x: i32 = i32(bits & 0xFFFFu);
  let off_z: i32 = i32((bits >> 16u) & 0xFFFFu);
  return vec2<i32>(off_x, off_z);
}

fn clip_choose_level(xz: vec2<f32>) -> u32 {
  let cam_xz = vec2<f32>(cam.cam_pos.x, cam.cam_pos.z);
  let d = max(abs(xz.x - cam_xz.x), abs(xz.y - cam_xz.y));

  let res_i = max(i32(clip.res), 1);
  let res_f = f32(res_i);

  var best: u32 = max(clip.levels, 1u) - 1u;

  let n = min(clip.levels, CLIP_LEVELS_MAX);
  for (var i: u32 = 0u; i < n; i = i + 1u) {
    let cell = clip.level[i].z;
    let half = 0.5 * res_f * cell;
    let inner = 0.45 * half;
    if (d <= inner) { best = i; break; }
  }

  return best;
}

fn clip_height_at_level(world_xz: vec2<f32>, level: u32) -> f32 {
  let res_i = max(i32(clip.res), 1);

  let p = clip.level[level];
  let origin = vec2<f32>(p.x, p.y);
  let cell   = max(p.z, 1e-6);
  let inv_cell = 1.0 / cell;

  // world -> logical texel
  let uv = (world_xz - origin) * inv_cell;

  var ix = i32(floor(uv.x));
  var iz = i32(floor(uv.y));

  ix = clamp(ix, 0, res_i - 1);
  iz = clamp(iz, 0, res_i - 1);

  let off = clip_unpack_offsets(level);
  let sx = imod(ix + off.x, res_i);
  let sz = imod(iz + off.y, res_i);

  return textureLoad(clip_height, vec2<i32>(sx, sz), i32(level), 0).x;
}

fn clip_height_at(xz: vec2<f32>) -> f32 {
  let lvl = clip_choose_level(xz);
  return clip_height_at_level(xz, lvl);
}

fn clip_normal_at_level_2tap(world_xz: vec2<f32>, level: u32) -> vec3<f32> {
  let cell = clip.level[level].z;

  let h  = clip_height_at_level(world_xz, level);
  let hx = clip_height_at_level(world_xz + vec2<f32>(cell, 0.0), level);
  let hz = clip_height_at_level(world_xz + vec2<f32>(0.0, cell), level);

  let dhx = (hx - h) / max(cell, 1e-4);
  let dhz = (hz - h) / max(cell, 1e-4);

  return normalize(vec3<f32>(-dhx, 1.0, -dhz));
}

fn clip_normal_at(xz: vec2<f32>) -> vec3<f32> {
  let lvl = clip_choose_level(xz);
  return clip_normal_at_level_2tap(xz, lvl);
}

struct ClipHit {
  hit : bool,
  t   : f32,
  n   : vec3<f32>,
  mat : u32,
};

fn clip_trace_heightfield(ro: vec3<f32>, rd: vec3<f32>, t_min: f32, t_max: f32) -> ClipHit {
  if (rd.y >= -1e-4) {
    return ClipHit(false, BIG_F32, vec3<f32>(0.0), MAT_AIR);
  }

  var t = max(t_min, 0.0);
  var p = ro + rd * t;

  var lvl: u32 = clip_choose_level(p.xz);

  var h = clip_height_at_level(p.xz, lvl);
  var s_prev = p.y - h;
  var t_prev = t;

  for (var i: u32 = 0u; i < HF_MAX_STEPS; i = i + 1u) {
    if (t > t_max) { break; }

    p = ro + rd * t;

    lvl = clip_choose_level(p.xz);

    h = clip_height_at_level(p.xz, lvl);
    let s = p.y - h;

    if (s <= 0.0 && s_prev > 0.0) {
      var a = t_prev;
      var b = t;

      for (var k: u32 = 0u; k < HF_BISECT; k = k + 1u) {
        let m = 0.5 * (a + b);
        let pm = ro + rd * m;

        let mlvl = clip_choose_level(pm.xz);
        let hm = clip_height_at_level(pm.xz, mlvl);
        let sm = pm.y - hm;

        if (sm > 0.0) { a = m; } else { b = m; }
      }

      let th = 0.5 * (a + b);
      let ph = ro + rd * th;

      let hlvl = clip_choose_level(ph.xz);
      let n = clip_normal_at_level_2tap(ph.xz, hlvl);

      return ClipHit(true, th, n, MAT_GRASS);
    }

    s_prev = s;
    t_prev = t;

    let vy = max(-rd.y, 0.12);
    var dt = abs(s) / vy;
    dt = clamp(dt, HF_DT_MIN, HF_DT_MAX);

    t = t + dt;
  }

  return ClipHit(false, BIG_F32, vec3<f32>(0.0), MAT_AIR);
}

fn shade_clip_hit(ro: vec3<f32>, rd: vec3<f32>, ch: ClipHit) -> vec3<f32> {
  let hp = ro + ch.t * rd;

  let base = color_for_material(ch.mat);

  let cloud = cloud_sun_transmittance(hp, SUN_DIR);
  let diff = max(dot(ch.n, SUN_DIR), 0.0);

  let ambient = 0.22;
  let direct = SUN_COLOR * SUN_INTENSITY * diff * cloud;

  return base * (ambient + (1.0 - ambient) * direct);
}

// src/shaders/common.wgsl
// -----------------------
// common.wgsl
//
// Shared WGSL across compute passes.
// - Constants / tuning knobs (ALL constants live here)
// - GPU-side struct defs + scene bindings
// - Shared math + grid helpers + sky/cloud/fog utilities

// ------------------------------------------------------------
// IDs / numeric
// ------------------------------------------------------------

const LEAF_U32 : u32 = 0xFFFFFFFFu; // Sentinel for "leaf node" in child_base.
const INVALID_U32 : u32 = 0xFFFFFFFFu; // Sentinel for invalid grid slot (chunk_grid entry).

const BIG_F32  : f32 = 1e30;
const EPS_INV  : f32 = 1e-8;

// Materials (keeps magic numbers out of core code)
const MAT_AIR   : u32 = 0u;
const MAT_GRASS : u32 = 1u;
const MAT_DIRT  : u32 = 2u;
const MAT_STONE : u32 = 3u;
const MAT_WOOD  : u32 = 4u;
const MAT_LEAF  : u32 = 5u;

// ------------------------------------------------------------
// Sun / sky
// ------------------------------------------------------------

const SUN_DIR : vec3<f32> = vec3<f32>(0.61237244, 0.5, 0.61237244);
const SUN_COLOR     : vec3<f32> = vec3<f32>(1.0, 0.98, 0.90);
const SUN_INTENSITY : f32 = 3.5;

const SUN_DISC_ANGULAR_RADIUS : f32 = 0.009;
const SUN_DISC_SOFTNESS       : f32 = 0.004;

const SKY_EXPOSURE : f32 = 0.40;

// ------------------------------------------------------------
// Shadows
// ------------------------------------------------------------

const SHADOW_BIAS : f32 = 2e-4;

// Shadow traversal tuning
const SHADOW_STEPS : u32 = 32u;

// If false: leaves cast shadows using their undisplaced cube (faster).
// If true : shadows match displaced leaf cubes (slower but consistent).
const SHADOW_DISPLACED_LEAVES : bool = false;

// Volumetric sun transmittance tuning (leafy canopy)
const VSM_STEPS : u32 = 24u;
const LEAF_LIGHT_TRANSMIT : f32 = 0.50;
const MIN_TRANS : f32 = 0.03;

// ------------------------------------------------------------
// Fog / volumetrics
// ------------------------------------------------------------

const FOG_HEIGHT_FALLOFF : f32 = 0.18;
const FOG_MAX_DIST       : f32 = 100.0;

const FOG_PRIMARY_SCALE : f32 = 0.02;
const FOG_GODRAY_SCALE  : f32 = 2.0;

const FOG_PRIMARY_VIS   : f32 = 0.08;

const FOG_COLOR_GROUND     : vec3<f32> = vec3<f32>(0.62, 0.64, 0.66);
const FOG_COLOR_SKY_BLEND  : f32 = 0.20;

const GODRAY_MAX_DIST    : f32 = 80.0;
const GODRAY_STRENGTH    : f32 = 4.0;

const GODRAY_OFFAXIS_POW : f32 = 3.0;
const GODRAY_OFFAXIS_W   : f32 = 0.18;

// Godray scattering height behavior (ONLY affects added beam light, not fog density)
const GODRAY_SCATTER_HEIGHT_FALLOFF : f32 = 0.04; // << smaller than FOG_HEIGHT_FALLOFF (0.18)
const GODRAY_SCATTER_MIN_FRAC       : f32 = 0.35; // floor as fraction of sea-level scatter

const GODRAY_SIDE_BOOST : f32 = 0.65; // 0..1
const GODRAY_BLACK_LEVEL : f32 = 0.018; // try 0.010..0.030

const GODRAY_TS_LP_ALPHA   : f32 = 0.50; // 0.2..0.5 (higher = smoother, less noisy)
const GODRAY_EDGE0         : f32 = 0.015;
const GODRAY_EDGE1         : f32 = 0.10;

const GODRAY_BASE_HAZE     : f32 = 0.08; // 0.02..0.10 (tiny DC term)
const GODRAY_HAZE_NEAR_FADE: f32 = 18.0; // meters: haze ramps in with distance


const INV_4PI      : f32 = 0.0795774715;
const PHASE_G      : f32 = 0.10;
const PHASE_MIE_W  : f32 = 0.25;

// ------------------------------------------------------------
// Fractal clouds
// ------------------------------------------------------------

const CLOUD_H : f32 = 200.0;
const CLOUD_UV_SCALE : f32 = 0.002;
const CLOUD_WIND : vec2<f32> = vec2<f32>(0.020, 0.012);

const CLOUD_COVERAGE : f32 = 0.45;
const CLOUD_SOFTNESS : f32 = 0.10;

const CLOUD_HORIZON_Y0 : f32 = 0.02;
const CLOUD_HORIZON_Y1 : f32 = 0.25;

const CLOUD_SKY_DARKEN : f32 = 0.95;
const CLOUD_ABSORB : f32 = 10.0;

const CLOUD_BASE_COL   : vec3<f32> = vec3<f32>(0.72, 0.74, 0.76);
const CLOUD_SILVER_POW : f32 = 8.0;
const CLOUD_SILVER_STR : f32 = 0.6;
const CLOUD_BLEND      : f32 = 0.85;

const CLOUD_DIM_SUN_DISC : bool = true;
const CLOUD_SUN_DISC_ABSORB_SCALE : f32 = 0.8;

// ------------------------------------------------------------
// Leaf wind (displaced cubes)
// ------------------------------------------------------------

const WIND_CELL_FREQ : f32 = 2.5;
const WIND_DIR_XZ : vec2<f32> = vec2<f32>(0.9, 0.4);

const WIND_RAMP_Y0 : f32 = 2.0;
const WIND_RAMP_Y1 : f32 = 14.0;

const WIND_GUST_TIME_FREQ    : f32 = 0.9;
const WIND_FLUTTER_TIME_FREQ : f32 = 4.2;

const WIND_GUST_XZ_FREQ    : vec2<f32> = vec2<f32>(0.35, 0.22);
const WIND_FLUTTER_XZ_FREQ : vec2<f32> = vec2<f32>(1.7,  1.1);

const WIND_GUST_WEIGHT    : f32 = 0.75;
const WIND_FLUTTER_WEIGHT : f32 = 0.25;

const WIND_VERTICAL_SCALE : f32 = 0.25;
const LEAF_VERTICAL_REDUCE : f32 = 0.15;

const LEAF_OFFSET_AMP : f32 = 0.45;
const LEAF_OFFSET_MAX_FRAC : f32 = 0.45;

const WIND_PHASE_OFF_1 : vec3<f32> = vec3<f32>(19.0, 7.0, 11.0);
const TAU : f32 = 6.28318530718;

// ------------------------------------------------------------
// Ray/main pass knobs (moved from ray_main)
// ------------------------------------------------------------

const PRIMARY_NUDGE_VOXEL_FRAC : f32 = 1e-4;

// Godray sampling pattern
const GODRAY_FRAME_FPS : f32 = 60.0;
const GODRAY_BLOCK_SIZE : i32 = 4;
const GODRAY_PATTERN_HASH_SCALE : f32 = 0.73;

const J0_SCALE : f32 = 1.31;
const J1_SCALE : f32 = 2.11;
const J2_SCALE : f32 = 3.01;
const J3_SCALE : f32 = 4.19;

const J0_F : vec2<f32> = vec2<f32>(0.11, 0.17);
const J1_F : vec2<f32> = vec2<f32>(0.23, 0.29);
const J2_F : vec2<f32> = vec2<f32>(0.37, 0.41);
const J3_F : vec2<f32> = vec2<f32>(0.53, 0.59);

const GODRAY_TV_CUTOFF : f32 = 0.02;
const GODRAY_STEPS_FAST : u32 = 8u;

// Composite
const COMPOSITE_SHARPEN : f32 = 0.35;
const COMPOSITE_GOD_SCALE : f32 = 3.0;
const COMPOSITE_BEAM_COMPRESS : bool = true;

// Post
const POST_EXPOSURE : f32 = 1.15;

// ------------------------------------------------------------
// GPU structs (must match Rust layouts)
// ------------------------------------------------------------

struct Node {
  child_base : u32,
  child_mask : u32,
  material   : u32,
  _pad       : u32,
};

struct Camera {
  view_inv    : mat4x4<f32>,
  proj_inv    : mat4x4<f32>,
  cam_pos     : vec4<f32>,

  chunk_size  : u32,
  chunk_count : u32,
  max_steps   : u32,
  _pad0       : u32,

  // x = voxel_size_m, y = time_seconds, z = wind_strength, w = fog_density
  voxel_params : vec4<f32>,

  grid_origin_chunk : vec4<i32>,
  grid_dims         : vec4<u32>,
};

struct ChunkMeta {
  origin     : vec4<i32>,
  node_base  : u32,
  node_count : u32,
  _pad0      : u32,
  _pad1      : u32,
};

// ------------------------------------------------------------
// Scene bindings (group(0))
// ------------------------------------------------------------

@group(0) @binding(0) var<uniform> cam : Camera;
@group(0) @binding(1) var<storage, read> chunks : array<ChunkMeta>;
@group(0) @binding(2) var<storage, read> nodes  : array<Node>;
@group(0) @binding(3) var<storage, read> chunk_grid : array<u32>;

// ------------------------------------------------------------
// Ray reconstruction
// ------------------------------------------------------------

fn ray_dir_from_pixel(px: vec2<f32>, res: vec2<f32>) -> vec3<f32> {
  let ndc = vec4<f32>(
    2.0 * px.x / res.x - 1.0,
    1.0 - 2.0 * px.y / res.y,
    1.0,
    1.0
  );

  let view = cam.proj_inv * ndc;
  let vdir = vec4<f32>(view.xyz / view.w, 0.0);
  let wdir = (cam.view_inv * vdir).xyz;
  return normalize(wdir);
}

// ------------------------------------------------------------
// AABB intersection (slab)
// ------------------------------------------------------------

fn intersect_aabb(ro: vec3<f32>, rd: vec3<f32>, bmin: vec3<f32>, bmax: vec3<f32>) -> vec2<f32> {
  let eps = 1e-8;

  var t_enter = -1e30;
  var t_exit  =  1e30;

  if (abs(rd.x) < eps) {
    if (ro.x < bmin.x || ro.x > bmax.x) { return vec2<f32>(1.0, 0.0); }
  } else {
    let inv = 1.0 / rd.x;
    let t0 = (bmin.x - ro.x) * inv;
    let t1 = (bmax.x - ro.x) * inv;
    t_enter = max(t_enter, min(t0, t1));
    t_exit  = min(t_exit,  max(t0, t1));
  }

  if (abs(rd.y) < eps) {
    if (ro.y < bmin.y || ro.y > bmax.y) { return vec2<f32>(1.0, 0.0); }
  } else {
    let inv = 1.0 / rd.y;
    let t0 = (bmin.y - ro.y) * inv;
    let t1 = (bmax.y - ro.y) * inv;
    t_enter = max(t_enter, min(t0, t1));
    t_exit  = min(t_exit,  max(t0, t1));
  }

  if (abs(rd.z) < eps) {
    if (ro.z < bmin.z || ro.z > bmax.z) { return vec2<f32>(1.0, 0.0); }
  } else {
    let inv = 1.0 / rd.z;
    let t0 = (bmin.z - ro.z) * inv;
    let t1 = (bmax.z - ro.z) * inv;
    t_enter = max(t_enter, min(t0, t1));
    t_exit  = min(t_exit,  max(t0, t1));
  }

  return vec2<f32>(t_enter, t_exit);
}

// ------------------------------------------------------------
// Sparse children addressing (compact child list)
// ------------------------------------------------------------

fn child_rank(mask: u32, ci: u32) -> u32 {
  let bit = 1u << ci;
  let lower = mask & (bit - 1u);
  return countOneBits(lower);
}

// ------------------------------------------------------------
// Chunk-grid helpers (moved from ray_main; used by shadows too)
// ------------------------------------------------------------

fn grid_lookup_slot(cx: i32, cy: i32, cz: i32) -> u32 {
  let ox = cam.grid_origin_chunk.x;
  let oy = cam.grid_origin_chunk.y;
  let oz = cam.grid_origin_chunk.z;

  let ix_i = cx - ox;
  let iy_i = cy - oy;
  let iz_i = cz - oz;

  if (ix_i < 0 || iy_i < 0 || iz_i < 0) { return INVALID_U32; }

  let nx = cam.grid_dims.x;
  let ny = cam.grid_dims.y;
  let nz = cam.grid_dims.z;

  let ix = u32(ix_i);
  let iy = u32(iy_i);
  let iz = u32(iz_i);

  if (ix >= nx || iy >= ny || iz >= nz) { return INVALID_U32; }

  let idx = (iz * ny * nx) + (iy * nx) + ix;
  return chunk_grid[idx];
}

fn chunk_coord_from_pos(p: vec3<f32>, chunk_size_m: f32) -> vec3<i32> {
  return vec3<i32>(
    i32(floor(p.x / chunk_size_m)),
    i32(floor(p.y / chunk_size_m)),
    i32(floor(p.z / chunk_size_m))
  );
}

// ------------------------------------------------------------
// Hash / noise / FBM (clouds)
// ------------------------------------------------------------

fn hash12(p: vec2<f32>) -> f32 {
  let h = dot(p, vec2<f32>(127.1, 311.7));
  return fract(sin(h) * 43758.5453);
}

fn hash21(p: vec2<f32>) -> f32 {
  let h = dot(p, vec2<f32>(127.1, 311.7));
  return fract(sin(h) * 43758.5453);
}

fn value_noise(p: vec2<f32>) -> f32 {
  let i = floor(p);
  let f = fract(p);

  let a = hash21(i);
  let b = hash21(i + vec2<f32>(1.0, 0.0));
  let c = hash21(i + vec2<f32>(0.0, 1.0));
  let d = hash21(i + vec2<f32>(1.0, 1.0));

  let u = f * f * (3.0 - 2.0 * f);

  let x1 = mix(a, b, u.x);
  let x2 = mix(c, d, u.x);
  return mix(x1, x2, u.y);
}

fn fbm(p: vec2<f32>) -> f32 {
  var x = p;
  var sum = 0.0;
  var amp = 0.5;

  let rot = mat2x2<f32>(0.8, -0.6, 0.6, 0.8);

  for (var i: u32 = 0u; i < 5u; i = i + 1u) {
    sum += amp * value_noise(x);
    x = rot * x * 2.0 + vec2<f32>(17.0, 9.0);
    amp *= 0.5;
  }
  return sum;
}

fn cloud_coverage_at_xz(xz: vec2<f32>, time_s: f32) -> f32 {
  var uv = xz * CLOUD_UV_SCALE + CLOUD_WIND * time_s;

  let n  = fbm(uv);
  let n2 = fbm(uv * 2.3 + vec2<f32>(13.2, 7.1));
  let field = 0.65 * n + 0.35 * n2;

  return smoothstep(CLOUD_COVERAGE, CLOUD_COVERAGE + CLOUD_SOFTNESS, field);
}

fn cloud_sun_transmittance(p: vec3<f32>, sun_dir: vec3<f32>) -> f32 {
  if (sun_dir.y <= 0.01) { return 1.0; }

  let t = (CLOUD_H - p.y) / sun_dir.y;
  if (t <= 0.0) { return 1.0; }

  let time_s = cam.voxel_params.y;
  let hit = p + sun_dir * t;
  let cov = cloud_coverage_at_xz(hit.xz, time_s);
  return exp(-CLOUD_ABSORB * cov);
}

// ------------------------------------------------------------
// Phase functions
// ------------------------------------------------------------

fn phase_mie(costh: f32) -> f32 {
  let g = PHASE_G;
  let gg = g * g;
  let denom = pow(1.0 + gg - 2.0 * g * costh, 1.5);
  return (1.0 - gg) / max(denom, 1e-3);
}

fn phase_blended(costh: f32) -> f32 {
  let mie = phase_mie(costh);
  return mix(INV_4PI, mie, PHASE_MIE_W);
}

// ------------------------------------------------------------
// Sky
// ------------------------------------------------------------

fn sky_color(rd: vec3<f32>) -> vec3<f32> {
  let tsky = clamp(0.5 * (rd.y + 1.0), 0.0, 1.0);
  var col = mix(
    vec3<f32>(0.05, 0.08, 0.12),
    vec3<f32>(0.55, 0.75, 0.95),
    tsky
  );

  col *= SKY_EXPOSURE;

  let mu  = dot(rd, SUN_DIR);
  let ang = acos(clamp(mu, -1.0, 1.0));
  let disc = 1.0 - smoothstep(
    SUN_DISC_ANGULAR_RADIUS,
    SUN_DISC_ANGULAR_RADIUS + SUN_DISC_SOFTNESS,
    ang
  );
  let halo = exp(-ang * 30.0) * 0.15;

  var cloud = 0.0;

  if (rd.y > 0.01) {
    let ro = cam.cam_pos.xyz;
    let t = (CLOUD_H - ro.y) / rd.y;

    if (t > 0.0) {
      let hit = ro + rd * t;
      let time_s = cam.voxel_params.y;

      cloud = cloud_coverage_at_xz(hit.xz, time_s);

      let horizon = clamp((rd.y - CLOUD_HORIZON_Y0) / CLOUD_HORIZON_Y1, 0.0, 1.0);
      cloud *= horizon;

      col *= mix(1.0, CLOUD_SKY_DARKEN, cloud);

      let toward_sun = clamp(mu, 0.0, 1.0);
      let silver = pow(toward_sun, CLOUD_SILVER_POW) * CLOUD_SILVER_STR;
      let cloud_col = mix(CLOUD_BASE_COL, vec3<f32>(1.0), silver);

      col = mix(col, cloud_col, cloud * CLOUD_BLEND);
    }
  }

  var sun_term = (disc + halo);
  if (CLOUD_DIM_SUN_DISC) {
    let Tc_view = exp(-CLOUD_ABSORB * cloud * CLOUD_SUN_DISC_ABSORB_SCALE);
    sun_term *= Tc_view;
  }

  col += SUN_COLOR * SUN_INTENSITY * sun_term;
  return col;
}

// Fog color used by primary composition
fn fog_color(rd: vec3<f32>) -> vec3<f32> {
  let up = clamp(rd.y * 0.5 + 0.5, 0.0, 1.0);
  let sky = sky_color(rd);
  return mix(FOG_COLOR_GROUND, sky, FOG_COLOR_SKY_BLEND * up);
}

// ------------------------------------------------------------
// Fog helpers
// ------------------------------------------------------------

fn fog_density_primary() -> f32 {
  return max(cam.voxel_params.w * FOG_PRIMARY_SCALE, 0.0);
}

fn fog_density_godray() -> f32 {
  return max(cam.voxel_params.w * FOG_GODRAY_SCALE, 0.0);
}

fn fog_optical_depth_with_base(base: f32, ro: vec3<f32>, rd: vec3<f32>, t: f32) -> f32 {
  if (base <= 0.0) { return 0.0; }

  let k = FOG_HEIGHT_FALLOFF;
  let y0 = ro.y;
  let dy = rd.y;

  if (abs(dy) < 1e-4) {
    return base * exp(-k * y0) * t;
  }

  let a = exp(-k * y0);
  let b = exp(-k * (y0 + dy * t));
  return base * (a - b) / (k * dy);
}

fn fog_transmittance_primary(ro: vec3<f32>, rd: vec3<f32>, t: f32) -> f32 {
  let od = max(fog_optical_depth_with_base(fog_density_primary(), ro, rd, t), 0.0);
  return exp(-od);
}

fn fog_transmittance_godray(ro: vec3<f32>, rd: vec3<f32>, t: f32) -> f32 {
  let od = max(fog_optical_depth_with_base(fog_density_godray(), ro, rd, t), 0.0);
  return exp(-od);
}

// src/shaders/ray_core.wgsl
// -------------------------
// ray_core.wgsl
//
// Consolidated core:
// - SVO queries + hybrid traversal
// - Leaf wind + displaced hit
// - Shadows + sun transmittance
// - Material palette + shading

// Depends on: common.wgsl (constants, structs, bindings, helpers)

fn safe_inv(x: f32) -> f32 {
  return select(1.0 / x, BIG_F32, abs(x) < EPS_INV);
}

// ------------------------------------------------------------
// Leaf query: point -> leaf cell in SVO
// ------------------------------------------------------------

struct LeafQuery {
  bmin : vec3<f32>,
  size : f32,
  mat  : u32,
};

fn query_leaf_at(
  p_in: vec3<f32>,
  root_bmin: vec3<f32>,
  root_size: f32,
  node_base: u32
) -> LeafQuery {
  var idx: u32 = node_base;
  var bmin: vec3<f32> = root_bmin;
  var size: f32 = root_size;

  let min_leaf: f32 = cam.voxel_params.x;
  var p = p_in;

  for (var d: u32 = 0u; d < 32u; d = d + 1u) {
    let n = nodes[idx];

    if (n.child_base == LEAF_U32) {
      return LeafQuery(bmin, size, n.material);
    }

    if (size <= min_leaf) {
      return LeafQuery(bmin, size, MAT_AIR);
    }

    let half = size * 0.5;
    let mid  = bmin + vec3<f32>(half);

    let e = 1e-6 * size;

    let hx = select(0u, 1u, p.x > mid.x + e);
    let hy = select(0u, 1u, p.y > mid.y + e);
    let hz = select(0u, 1u, p.z > mid.z + e);
    let ci = hx | (hy << 1u) | (hz << 2u);

    let child_bmin = bmin + vec3<f32>(
      select(0.0, half, hx != 0u),
      select(0.0, half, hy != 0u),
      select(0.0, half, hz != 0u)
    );

    let bit = 1u << ci;
    if ((n.child_mask & bit) == 0u) {
      return LeafQuery(child_bmin, half, MAT_AIR);
    }

    let rank = child_rank(n.child_mask, ci);
    idx = node_base + (n.child_base + rank);

    bmin = child_bmin;
    size = half;
  }

  return LeafQuery(bmin, size, MAT_AIR);
}

// ------------------------------------------------------------
// Fast stepping: cube exit time with inv dir
// ------------------------------------------------------------

fn exit_time_from_cube_inv(
  ro: vec3<f32>,
  rd: vec3<f32>,
  inv: vec3<f32>,
  bmin: vec3<f32>,
  size: f32
) -> f32 {
  let bmax = bmin + vec3<f32>(size);

  let tx = (select(bmin.x, bmax.x, rd.x > 0.0) - ro.x) * inv.x;
  let ty = (select(bmin.y, bmax.y, rd.y > 0.0) - ro.y) * inv.y;
  let tz = (select(bmin.z, bmax.z, rd.z > 0.0) - ro.z) * inv.z;

  return min(tx, min(ty, tz));
}

// ------------------------------------------------------------
// AABB hit + stable normal selection
// ------------------------------------------------------------

struct BoxHit {
  hit : bool,
  t   : f32,
  n   : vec3<f32>,
};

fn aabb_hit_normal_inv(
  ro: vec3<f32>,
  rd: vec3<f32>,
  inv: vec3<f32>,
  bmin: vec3<f32>,
  size: f32,
  t_min: f32,
  t_max: f32
) -> BoxHit {
  let bmax = bmin + vec3<f32>(size);

  let tx0 = (bmin.x - ro.x) * inv.x;
  let tx1 = (bmax.x - ro.x) * inv.x;
  let ty0 = (bmin.y - ro.y) * inv.y;
  let ty1 = (bmax.y - ro.y) * inv.y;
  let tz0 = (bmin.z - ro.z) * inv.z;
  let tz1 = (bmax.z - ro.z) * inv.z;

  let tminx = min(tx0, tx1);
  let tmaxx = max(tx0, tx1);
  let tminy = min(ty0, ty1);
  let tmaxy = max(ty0, ty1);
  let tminz = min(tz0, tz1);
  let tmaxz = max(tz0, tz1);

  let t_enter = max(tminx, max(tminy, tminz));
  let t_exit  = min(tmaxx, min(tmaxy, tmaxz));

  let t0 = max(t_enter, t_min);

  if (t_exit < t0 || t0 > t_max) {
    return BoxHit(false, BIG_F32, vec3<f32>(0.0));
  }

  let eps = 1e-6 * size;

  var best_abs = -1.0;
  var pick: u32 = 0u;

  if (abs(t_enter - tminx) <= eps) {
    let a = abs(rd.x);
    if (a > best_abs) { best_abs = a; pick = 0u; }
  }
  if (abs(t_enter - tminy) <= eps) {
    let a = abs(rd.y);
    if (a > best_abs) { best_abs = a; pick = 1u; }
  }
  if (abs(t_enter - tminz) <= eps) {
    let a = abs(rd.z);
    if (a > best_abs) { best_abs = a; pick = 2u; }
  }

  var n = vec3<f32>(0.0);
  if (pick == 0u) { n = vec3<f32>(select( 1.0, -1.0, rd.x > 0.0), 0.0, 0.0); }
  if (pick == 1u) { n = vec3<f32>(0.0, select( 1.0, -1.0, rd.y > 0.0), 0.0); }
  if (pick == 2u) { n = vec3<f32>(0.0, 0.0, select( 1.0, -1.0, rd.z > 0.0)); }

  return BoxHit(true, t0, n);
}

// ------------------------------------------------------------
// Leaf wind field + displaced cube hit
// ------------------------------------------------------------

fn hash1(p: vec3<f32>) -> f32 {
  let h = dot(p, vec3<f32>(127.1, 311.7, 74.7));
  return fract(sin(h) * 43758.5453);
}

fn wind_field(pos_m: vec3<f32>, t: f32) -> vec3<f32> {
  let cell = floor(pos_m * WIND_CELL_FREQ);

  let ph0 = hash1(cell);
  let ph1 = hash1(cell + WIND_PHASE_OFF_1);

  let dir = normalize(WIND_DIR_XZ);

  let h = clamp((pos_m.y - WIND_RAMP_Y0) / max(WIND_RAMP_Y1 - WIND_RAMP_Y0, 1e-3), 0.0, 1.0);

  let gust = sin(
    t * WIND_GUST_TIME_FREQ +
    dot(pos_m.xz, WIND_GUST_XZ_FREQ) +
    ph0 * TAU
  );

  let flutter = sin(
    t * WIND_FLUTTER_TIME_FREQ +
    dot(pos_m.xz, WIND_FLUTTER_XZ_FREQ) +
    ph1 * TAU
  );

  let xz = dir * (WIND_GUST_WEIGHT * gust + WIND_FLUTTER_WEIGHT * flutter) * h;
  let y  = WIND_VERTICAL_SCALE * flutter * h;

  return vec3<f32>(xz.x, y, xz.y);
}

fn clamp_len(v: vec3<f32>, max_len: f32) -> vec3<f32> {
  let l2 = dot(v, v);
  if (l2 <= max_len * max_len) { return v; }
  return v * (max_len / sqrt(l2));
}

fn leaf_cube_offset(bmin: vec3<f32>, size: f32, time_s: f32, strength: f32) -> vec3<f32> {
  let center = bmin + vec3<f32>(0.5 * size);

  var w = wind_field(center, time_s) * strength;
  w = vec3<f32>(w.x, LEAF_VERTICAL_REDUCE * w.y, w.z);

  let amp = LEAF_OFFSET_AMP * size;
  return clamp_len(w * amp, LEAF_OFFSET_MAX_FRAC * size);
}

struct LeafCubeHit {
  hit  : bool,
  t    : f32,
  n    : vec3<f32>,
};

fn leaf_displaced_cube_hit(
  ro: vec3<f32>,
  rd: vec3<f32>,
  bmin: vec3<f32>,
  size: f32,
  time_s: f32,
  strength: f32,
  t_min: f32,
  t_max: f32
) -> LeafCubeHit {
  let off   = leaf_cube_offset(bmin, size, time_s, strength);
  let bmin2 = bmin + off;

  let inv = vec3<f32>(safe_inv(rd.x), safe_inv(rd.y), safe_inv(rd.z));
  let bh  = aabb_hit_normal_inv(ro, rd, inv, bmin2, size, t_min, t_max);

  return LeafCubeHit(bh.hit, bh.t, bh.n);
}

// ------------------------------------------------------------
// Chunk tracing: hybrid point-query + interval stepping
// ------------------------------------------------------------

struct HitGeom {
  hit : bool,
  t   : f32,
  mat : u32,
  n   : vec3<f32>,
};

fn trace_chunk_hybrid_interval(
  ro: vec3<f32>,
  rd: vec3<f32>,
  ch: ChunkMeta,
  t_enter: f32,
  t_exit: f32
) -> HitGeom {
  let voxel_size = cam.voxel_params.x;

  let root_bmin_vox = vec3<f32>(f32(ch.origin.x), f32(ch.origin.y), f32(ch.origin.z));
  let root_bmin = root_bmin_vox * voxel_size;
  let root_size = f32(cam.chunk_size) * voxel_size;

  let eps_step = 1e-4 * voxel_size;

  var tcur = max(t_enter, 0.0) + eps_step;

  let inv = vec3<f32>(safe_inv(rd.x), safe_inv(rd.y), safe_inv(rd.z));

  for (var step_i: u32 = 0u; step_i < cam.max_steps; step_i = step_i + 1u) {
    if (tcur > t_exit) { break; }

    let p  = ro + tcur * rd;
    let pq = p + rd * (1e-4 * voxel_size);

    let q = query_leaf_at(pq, root_bmin, root_size, ch.node_base);

    if (q.mat != MAT_AIR) {
      if (q.mat == MAT_LEAF) {
        let time_s   = cam.voxel_params.y;
        let strength = cam.voxel_params.z;

        let h2 = leaf_displaced_cube_hit(
          ro, rd,
          q.bmin, q.size,
          time_s, strength,
          t_enter,
          t_exit
        );

        if (h2.hit) {
          return HitGeom(true, h2.t, MAT_LEAF, h2.n);
        }

        let t_leave = exit_time_from_cube_inv(ro, rd, inv, q.bmin, q.size);
        tcur = max(t_leave, tcur) + eps_step;
        continue;
      }

      let bh = aabb_hit_normal_inv(
        ro, rd, inv,
        q.bmin, q.size,
        t_enter,
        t_exit
      );

      if (bh.hit) {
        return HitGeom(true, bh.t, q.mat, bh.n);
      }

      let t_leave = exit_time_from_cube_inv(ro, rd, inv, q.bmin, q.size);
      tcur = max(t_leave, tcur) + eps_step;
      continue;
    }

    let t_leave = exit_time_from_cube_inv(ro, rd, inv, q.bmin, q.size);
    tcur = max(t_leave, tcur) + eps_step;
  }

  return HitGeom(false, BIG_F32, MAT_AIR, vec3<f32>(0.0));
}

// ------------------------------------------------------------
// Shadow traversal
// ------------------------------------------------------------

fn trace_chunk_shadow_interval(
  ro: vec3<f32>,
  rd: vec3<f32>,
  ch: ChunkMeta,
  t_enter: f32,
  t_exit: f32
) -> bool {
  let voxel_size = cam.voxel_params.x;
  let nudge_s = 0.18 * voxel_size;

  let root_bmin_vox = vec3<f32>(f32(ch.origin.x), f32(ch.origin.y), f32(ch.origin.z));
  let root_bmin = root_bmin_vox * voxel_size;
  let root_size = f32(cam.chunk_size) * voxel_size;

  var tcur = max(t_enter, 0.0) + nudge_s;
  let inv = vec3<f32>(safe_inv(rd.x), safe_inv(rd.y), safe_inv(rd.z));

  for (var step_i: u32 = 0u; step_i < SHADOW_STEPS; step_i = step_i + 1u) {
    if (tcur > t_exit) { break; }

    let p = ro + tcur * rd;
    let q = query_leaf_at(p, root_bmin, root_size, ch.node_base);

    if (q.mat != MAT_AIR) {
      if (q.mat == MAT_LEAF) {
        if (!SHADOW_DISPLACED_LEAVES) {
          return true;
        }

        let time_s   = cam.voxel_params.y;
        let strength = cam.voxel_params.z;

        let h2 = leaf_displaced_cube_hit(
          ro, rd,
          q.bmin, q.size,
          time_s, strength,
          tcur - nudge_s,
          t_exit
        );

        if (h2.hit) { return true; }

        let t_leave = exit_time_from_cube_inv(ro, rd, inv, q.bmin, q.size);
        tcur = max(t_leave, tcur) + nudge_s;
        continue;
      }

      return true;
    }

    let t_leave = exit_time_from_cube_inv(ro, rd, inv, q.bmin, q.size);
    tcur = max(t_leave, tcur) + nudge_s;
  }

  return false;
}

fn in_shadow(p: vec3<f32>, sun_dir: vec3<f32>) -> bool {
  let voxel_size   = cam.voxel_params.x;
  let nudge_s      = 0.18 * voxel_size;
  let chunk_size_m = f32(cam.chunk_size) * voxel_size;

  let go = cam.grid_origin_chunk;
  let gd = cam.grid_dims;

  let grid_bmin = vec3<f32>(
    f32(go.x) * chunk_size_m,
    f32(go.y) * chunk_size_m,
    f32(go.z) * chunk_size_m
  );

  let grid_bmax = grid_bmin + vec3<f32>(
    f32(gd.x) * chunk_size_m,
    f32(gd.y) * chunk_size_m,
    f32(gd.z) * chunk_size_m
  );

  let bias = max(SHADOW_BIAS, 0.50 * voxel_size);
  let ro   = p + sun_dir * bias;
  let rd   = sun_dir;

  let rtg = intersect_aabb(ro, rd, grid_bmin, grid_bmax);
  let t_enter = max(rtg.x, 0.0);
  let t_exit  = rtg.y;
  if (t_exit < t_enter) { return false; }

  let start_t = t_enter + nudge_s;
  let p0 = ro + start_t * rd;

  var t_local: f32 = 0.0;
  let t_exit_local = max(t_exit - start_t, 0.0);

  var c = chunk_coord_from_pos(p0, chunk_size_m);
  var cx: i32 = c.x;
  var cy: i32 = c.y;
  var cz: i32 = c.z;

  let inv = vec3<f32>(safe_inv(rd.x), safe_inv(rd.y), safe_inv(rd.z));

  let step_x: i32 = select(-1, 1, rd.x > 0.0);
  let step_y: i32 = select(-1, 1, rd.y > 0.0);
  let step_z: i32 = select(-1, 1, rd.z > 0.0);

  let bx = select(f32(cx) * chunk_size_m, f32(cx + 1) * chunk_size_m, rd.x > 0.0);
  let by = select(f32(cy) * chunk_size_m, f32(cy + 1) * chunk_size_m, rd.y > 0.0);
  let bz = select(f32(cz) * chunk_size_m, f32(cz + 1) * chunk_size_m, rd.z > 0.0);

  var tMaxX: f32 = (bx - p0.x) * inv.x;
  var tMaxY: f32 = (by - p0.y) * inv.y;
  var tMaxZ: f32 = (bz - p0.z) * inv.z;

  let tDeltaX: f32 = abs(chunk_size_m * inv.x);
  let tDeltaY: f32 = abs(chunk_size_m * inv.y);
  let tDeltaZ: f32 = abs(chunk_size_m * inv.z);

  if (abs(rd.x) < EPS_INV) { tMaxX = BIG_F32; }
  if (abs(rd.y) < EPS_INV) { tMaxY = BIG_F32; }
  if (abs(rd.z) < EPS_INV) { tMaxZ = BIG_F32; }

  let max_chunk_steps = min((gd.x + gd.y + gd.z) * 6u + 8u, 1024u);

  for (var s: u32 = 0u; s < max_chunk_steps; s = s + 1u) {
    if (t_local > t_exit_local) { break; }

    let tNextLocal = min(tMaxX, min(tMaxY, tMaxZ));

    let slot = grid_lookup_slot(cx, cy, cz);
    if (slot != INVALID_U32 && slot < cam.chunk_count) {
      let ch = chunks[slot];

      let cell_enter = start_t + t_local;
      let cell_exit  = start_t + min(tNextLocal, t_exit_local);

      if (trace_chunk_shadow_interval(ro, rd, ch, cell_enter, cell_exit)) {
        return true;
      }
    }

    if (tMaxX < tMaxY) {
      if (tMaxX < tMaxZ) { cx += step_x; t_local = tMaxX; tMaxX += tDeltaX; }
      else               { cz += step_z; t_local = tMaxZ; tMaxZ += tDeltaZ; }
    } else {
      if (tMaxY < tMaxZ) { cy += step_y; t_local = tMaxY; tMaxY += tDeltaY; }
      else               { cz += step_z; t_local = tMaxZ; tMaxZ += tDeltaZ; }
    }

    let ox = cam.grid_origin_chunk.x;
    let oy = cam.grid_origin_chunk.y;
    let oz = cam.grid_origin_chunk.z;

    let nx = i32(cam.grid_dims.x);
    let ny = i32(cam.grid_dims.y);
    let nz = i32(cam.grid_dims.z);

    if (cx < ox || cy < oy || cz < oz || cx >= ox + nx || cy >= oy + ny || cz >= oz + nz) {
      break;
    }
  }

  return false;
}

fn trace_chunk_shadow_trans_interval(
  ro: vec3<f32>,
  rd: vec3<f32>,
  ch: ChunkMeta,
  t_enter: f32,
  t_exit: f32
) -> f32 {
  let voxel_size = cam.voxel_params.x;
  let nudge_s = 0.18 * voxel_size;

  let root_bmin_vox = vec3<f32>(f32(ch.origin.x), f32(ch.origin.y), f32(ch.origin.z));
  let root_bmin = root_bmin_vox * voxel_size;
  let root_size = f32(cam.chunk_size) * voxel_size;

  var tcur = max(t_enter, 0.0) + nudge_s;
  let inv = vec3<f32>(safe_inv(rd.x), safe_inv(rd.y), safe_inv(rd.z));

  var trans = 1.0;

  for (var step_i: u32 = 0u; step_i < VSM_STEPS; step_i = step_i + 1u) {
    if (tcur > t_exit) { break; }
    if (trans < MIN_TRANS) { break; }

    let p = ro + tcur * rd;
    let qeps = 1e-4 * cam.voxel_params.x;
    let pq   = p + rd * qeps;

    let q = query_leaf_at(pq, root_bmin, root_size, ch.node_base);

    if (q.mat != MAT_AIR) {
      if (q.mat == MAT_LEAF) {
        trans *= LEAF_LIGHT_TRANSMIT;
        let t_leave = exit_time_from_cube_inv(ro, rd, inv, q.bmin, q.size);
        tcur = max(t_leave, tcur) + nudge_s;
        continue;
      }
      return 0.0;
    }

    let t_leave = exit_time_from_cube_inv(ro, rd, inv, q.bmin, q.size);
    tcur = max(t_leave, tcur) + nudge_s;
  }

  return trans;
}

fn sun_transmittance(p: vec3<f32>, sun_dir: vec3<f32>) -> f32 {
  let Tc = cloud_sun_transmittance(p, sun_dir);

  let voxel_size   = cam.voxel_params.x;
  let nudge_s      = 0.18 * voxel_size;
  let chunk_size_m = f32(cam.chunk_size) * voxel_size;

  let go = cam.grid_origin_chunk;
  let gd = cam.grid_dims;

  let grid_bmin = vec3<f32>(
    f32(go.x) * chunk_size_m,
    f32(go.y) * chunk_size_m,
    f32(go.z) * chunk_size_m
  );

  let grid_bmax = grid_bmin + vec3<f32>(
    f32(gd.x) * chunk_size_m,
    f32(gd.y) * chunk_size_m,
    f32(gd.z) * chunk_size_m
  );

  let bias = max(SHADOW_BIAS, 0.50 * voxel_size);
  let ro   = p + sun_dir * bias;
  let rd   = sun_dir;

  let rtg = intersect_aabb(ro, rd, grid_bmin, grid_bmax);
  let t_enter = max(rtg.x, 0.0);
  let t_exit  = rtg.y;
  if (t_exit < t_enter) { return Tc; }

  let start_t = t_enter + nudge_s;
  let p0 = ro + start_t * rd;

  var t_local: f32 = 0.0;
  let t_exit_local = max(t_exit - start_t, 0.0);

  var c = chunk_coord_from_pos(p0, chunk_size_m);
  var cx: i32 = c.x;
  var cy: i32 = c.y;
  var cz: i32 = c.z;

  let inv = vec3<f32>(safe_inv(rd.x), safe_inv(rd.y), safe_inv(rd.z));

  let step_x: i32 = select(-1, 1, rd.x > 0.0);
  let step_y: i32 = select(-1, 1, rd.y > 0.0);
  let step_z: i32 = select(-1, 1, rd.z > 0.0);

  let bx = select(f32(cx) * chunk_size_m, f32(cx + 1) * chunk_size_m, rd.x > 0.0);
  let by = select(f32(cy) * chunk_size_m, f32(cy + 1) * chunk_size_m, rd.y > 0.0);
  let bz = select(f32(cz) * chunk_size_m, f32(cz + 1) * chunk_size_m, rd.z > 0.0);

  var tMaxX: f32 = (bx - p0.x) * inv.x;
  var tMaxY: f32 = (by - p0.y) * inv.y;
  var tMaxZ: f32 = (bz - p0.z) * inv.z;

  let tDeltaX: f32 = abs(chunk_size_m * inv.x);
  let tDeltaY: f32 = abs(chunk_size_m * inv.y);
  let tDeltaZ: f32 = abs(chunk_size_m * inv.z);

  if (abs(rd.x) < EPS_INV) { tMaxX = BIG_F32; }
  if (abs(rd.y) < EPS_INV) { tMaxY = BIG_F32; }
  if (abs(rd.z) < EPS_INV) { tMaxZ = BIG_F32; }

  var trans = 1.0;

  let max_chunk_steps = min((gd.x + gd.y + gd.z) * 6u + 8u, 512u);

  for (var s: u32 = 0u; s < max_chunk_steps; s = s + 1u) {
    if (t_local > t_exit_local) { break; }
    if (trans < MIN_TRANS) { break; }

    let tNextLocal = min(tMaxX, min(tMaxY, tMaxZ));
    let slot = grid_lookup_slot(cx, cy, cz);

    if (slot != INVALID_U32 && slot < cam.chunk_count) {
      let ch = chunks[slot];

      let cell_enter = start_t + t_local;
      let cell_exit  = start_t + min(tNextLocal, t_exit_local);

      trans *= trace_chunk_shadow_trans_interval(ro, rd, ch, cell_enter, cell_exit);
      if (trans < MIN_TRANS) { break; }
    }

    if (tMaxX < tMaxY) {
      if (tMaxX < tMaxZ) { cx += step_x; t_local = tMaxX; tMaxX += tDeltaX; }
      else               { cz += step_z; t_local = tMaxZ; tMaxZ += tDeltaZ; }
    } else {
      if (tMaxY < tMaxZ) { cy += step_y; t_local = tMaxY; tMaxY += tDeltaY; }
      else               { cz += step_z; t_local = tMaxZ; tMaxZ += tDeltaZ; }
    }

    let ox = cam.grid_origin_chunk.x;
    let oy = cam.grid_origin_chunk.y;
    let oz = cam.grid_origin_chunk.z;

    let nx = i32(cam.grid_dims.x);
    let ny = i32(cam.grid_dims.y);
    let nz = i32(cam.grid_dims.z);

    if (cx < ox || cy < oy || cz < oz || cx >= ox + nx || cy >= oy + ny || cz >= oz + nz) {
      break;
    }
  }

  return trans * Tc;
}

// ------------------------------------------------------------
// Shading
// ------------------------------------------------------------

fn color_for_material(m: u32) -> vec3<f32> {
  if (m == MAT_AIR)   { return vec3<f32>(0.0); }

  if (m == MAT_GRASS) { return vec3<f32>(0.18, 0.75, 0.18); }
  if (m == MAT_DIRT)  { return vec3<f32>(0.45, 0.30, 0.15); }
  if (m == MAT_STONE) { return vec3<f32>(0.50, 0.50, 0.55); }
  if (m == MAT_WOOD)  { return vec3<f32>(0.38, 0.26, 0.14); }
  if (m == MAT_LEAF)  { return vec3<f32>(0.10, 0.55, 0.12); }

  return vec3<f32>(1.0, 0.0, 1.0);
}

fn shade_hit(ro: vec3<f32>, rd: vec3<f32>, hg: HitGeom) -> vec3<f32> {
  let hp = ro + hg.t * rd;
  let base = color_for_material(hg.mat);

  let voxel_size = cam.voxel_params.x;
  let hp_shadow  = hp + hg.n * (0.75 * voxel_size);

  let shadow = select(1.0, 0.0, in_shadow(hp_shadow, SUN_DIR));
  let cloud = cloud_sun_transmittance(hp_shadow, SUN_DIR);

  let diff = max(dot(hg.n, SUN_DIR), 0.0);

  let ambient = select(0.22, 0.28, hg.mat == MAT_LEAF);

  var dapple = 1.0;
  if (hg.mat == MAT_LEAF) {
    let time_s = cam.voxel_params.y;
    let d0 = sin(dot(hp.xz, vec2<f32>(3.0, 2.2)) + time_s * 3.5);
    let d1 = sin(dot(hp.xz, vec2<f32>(6.5, 4.1)) - time_s * 6.0);
    dapple = 0.90 + 0.10 * (0.6 * d0 + 0.4 * d1);
  }

  let direct = SUN_COLOR * SUN_INTENSITY * diff * shadow * cloud;
  return base * (ambient + (1.0 - ambient) * direct) * dapple;
}

// src/shaders/ray_main.wgsl
// -------------------------
// src/shaders/ray_main.wgsl
// -------------------------
// ray_main.wgsl
//
// Compute entrypoints only.
// Depends on: common.wgsl + ray_core.wgsl + clipmap.wgsl

@group(0) @binding(4) var color_img : texture_storage_2d<rgba16float, write>;
@group(0) @binding(5) var depth_img : texture_storage_2d<r32float, write>;

@group(1) @binding(0) var depth_tex       : texture_2d<f32>;
@group(1) @binding(1) var godray_hist_tex : texture_2d<f32>;
@group(1) @binding(2) var godray_out      : texture_storage_2d<rgba16float, write>;

@group(2) @binding(0) var color_tex  : texture_2d<f32>;
@group(2) @binding(1) var godray_tex : texture_2d<f32>;
@group(2) @binding(2) var out_img    : texture_storage_2d<rgba16float, write>;

fn tonemap_exp(hdr: vec3<f32>) -> vec3<f32> {
  return vec3<f32>(1.0) - exp(-hdr * POST_EXPOSURE);
}

// Quarter-res upsample (manual bilerp)
fn godray_sample_bilerp(px_full: vec2<f32>) -> vec3<f32> {
  let q = px_full * 0.25;
  let q0 = vec2<i32>(i32(floor(q.x)), i32(floor(q.y)));
  let f  = fract(q);

  let qdims = textureDimensions(godray_tex);
  let x0 = clamp(q0.x, 0, i32(qdims.x) - 1);
  let y0 = clamp(q0.y, 0, i32(qdims.y) - 1);
  let x1 = min(x0 + 1, i32(qdims.x) - 1);
  let y1 = min(y0 + 1, i32(qdims.y) - 1);

  let c00 = textureLoad(godray_tex, vec2<i32>(x0, y0), 0).xyz;
  let c10 = textureLoad(godray_tex, vec2<i32>(x1, y0), 0).xyz;
  let c01 = textureLoad(godray_tex, vec2<i32>(x0, y1), 0).xyz;
  let c11 = textureLoad(godray_tex, vec2<i32>(x1, y1), 0).xyz;

  let cx0 = mix(c00, c10, f.x);
  let cx1 = mix(c01, c11, f.x);
  return mix(cx0, cx1, f.y);
}

fn godray_integrate(ro: vec3<f32>, rd: vec3<f32>, t_end: f32, j: f32) -> vec3<f32> {
  let base = fog_density_godray();
  if (base <= 0.0 || t_end <= 0.0) { return vec3<f32>(0.0); }

  let costh = dot(rd, SUN_DIR);
  let phase = phase_blended(costh);

  let dt = t_end / f32(GODRAY_STEPS_FAST);

  var sum = vec3<f32>(0.0);

  var ts_lp: f32    = 1.0;
  var shaft_lp: f32 = 0.0;

  let a_ts    = 1.0 - exp(-dt * 3.0);
  let a_shaft = 1.0 - exp(-dt * 5.0);

  for (var i: u32 = 0u; i < GODRAY_STEPS_FAST; i = i + 1u) {
    let ti = (f32(i) + 0.5 + j) * dt;
    if (ti <= 0.0) { continue; }

    let p = ro + rd * ti;

    let Tv = fog_transmittance_godray(ro, rd, ti);
    if (Tv < GODRAY_TV_CUTOFF) { break; }

    let Ts0 = sun_transmittance(p, SUN_DIR);
    let Ts_soft = pow(clamp(Ts0, 0.0, 1.0), 0.75);

    let ts_prev = ts_lp;
    ts_lp = mix(ts_lp, Ts_soft, a_ts);

    let dTs = abs(Ts_soft - ts_prev);

    var shaft = smoothstep(GODRAY_EDGE0, GODRAY_EDGE1, dTs);
    shaft = sqrt(shaft);
    shaft_lp = mix(shaft_lp, shaft, a_shaft);
    shaft = shaft_lp;

    let haze_ramp = 1.0 - exp(-ti / GODRAY_HAZE_NEAR_FADE);
    let haze = GODRAY_BASE_HAZE * haze_ramp;

    let shaft_sun_gate = smoothstep(0.10, 0.55, ts_lp);

    let w = haze + (1.0 - haze) * (shaft * shaft_sun_gate);

    let hfall = GODRAY_SCATTER_HEIGHT_FALLOFF;
    let hmin  = GODRAY_SCATTER_MIN_FRAC;
    let height_term = max(exp(-hfall * p.y), hmin);

    let dens = base * height_term;

    let strength_scale = 0.70;

    sum += (SUN_COLOR * SUN_INTENSITY) * (dens * dt) * Tv * ts_lp * phase * w * strength_scale;
  }

  return sum * GODRAY_STRENGTH;
}

@compute @workgroup_size(8, 8, 1)
fn main_primary(@builtin(global_invocation_id) gid: vec3<u32>) {
  let dims = textureDimensions(color_img);
  if (gid.x >= dims.x || gid.y >= dims.y) { return; }

  let res = vec2<f32>(f32(dims.x), f32(dims.y));
  let px  = vec2<f32>(f32(gid.x) + 0.5, f32(gid.y) + 0.5);

  let ro = cam.cam_pos.xyz;
  let rd = ray_dir_from_pixel(px, res);

  let sky = sky_color(rd);

  let voxel_size = cam.voxel_params.x;
  let nudge_p = PRIMARY_NUDGE_VOXEL_FRAC * voxel_size;

  // If no SVO chunks, still render clipmap terrain.
  if (cam.chunk_count == 0u) {
    let hf = clip_trace_heightfield(ro, rd, 0.0, FOG_MAX_DIST);

    let surface = select(sky, shade_clip_hit(ro, rd, hf), hf.hit);
    let t_scene = select(FOG_MAX_DIST, min(hf.t, FOG_MAX_DIST), hf.hit);

    let T = fog_transmittance_primary(ro, rd, t_scene);
    let fogc = fog_color(rd);
    let fog_amt = (1.0 - T) * FOG_PRIMARY_VIS;
    let col = mix(surface, fogc, fog_amt);

    let ip = vec2<i32>(i32(gid.x), i32(gid.y));
    textureStore(color_img, ip, vec4<f32>(col, 1.0));
    textureStore(depth_img, ip, vec4<f32>(t_scene, 0.0, 0.0, 0.0));
    return;
  }

  let chunk_size_m = f32(cam.chunk_size) * voxel_size;

  let go = cam.grid_origin_chunk;
  let gd = cam.grid_dims;

  let grid_bmin = vec3<f32>(
    f32(go.x) * chunk_size_m,
    f32(go.y) * chunk_size_m,
    f32(go.z) * chunk_size_m
  );

  let grid_bmax = grid_bmin + vec3<f32>(
    f32(gd.x) * chunk_size_m,
    f32(gd.y) * chunk_size_m,
    f32(gd.z) * chunk_size_m
  );

  let rtg = intersect_aabb(ro, rd, grid_bmin, grid_bmax);
  var t_enter = max(rtg.x, 0.0);
  let t_exit  = rtg.y;

  // Outside streamed SVO grid => clipmap fallback.
  if (t_exit < t_enter) {
    let hf = clip_trace_heightfield(ro, rd, 0.0, FOG_MAX_DIST);

    let surface = select(sky, shade_clip_hit(ro, rd, hf), hf.hit);
    let t_scene = select(FOG_MAX_DIST, min(hf.t, FOG_MAX_DIST), hf.hit);

    let T = fog_transmittance_primary(ro, rd, t_scene);
    let fogc = fog_color(rd);
    let fog_amt = (1.0 - T) * FOG_PRIMARY_VIS;
    let col = mix(surface, fogc, fog_amt);

    let ip = vec2<i32>(i32(gid.x), i32(gid.y));
    textureStore(color_img, ip, vec4<f32>(col, 1.0));
    textureStore(depth_img, ip, vec4<f32>(t_scene, 0.0, 0.0, 0.0));
    return;
  }

  let start_t = t_enter + nudge_p;
  let p0 = ro + start_t * rd;

  var c = chunk_coord_from_pos(p0, chunk_size_m);
  var cx: i32 = c.x;
  var cy: i32 = c.y;
  var cz: i32 = c.z;

  var t_local: f32 = 0.0;

  let inv = vec3<f32>(safe_inv(rd.x), safe_inv(rd.y), safe_inv(rd.z));
  let step_x: i32 = select(-1, 1, rd.x > 0.0);
  let step_y: i32 = select(-1, 1, rd.y > 0.0);
  let step_z: i32 = select(-1, 1, rd.z > 0.0);

  let bx = select(f32(cx) * chunk_size_m, f32(cx + 1) * chunk_size_m, rd.x > 0.0);
  let by = select(f32(cy) * chunk_size_m, f32(cy + 1) * chunk_size_m, rd.y > 0.0);
  let bz = select(f32(cz) * chunk_size_m, f32(cz + 1) * chunk_size_m, rd.z > 0.0);

  var tMaxX: f32 = (bx - p0.x) * inv.x;
  var tMaxY: f32 = (by - p0.y) * inv.y;
  var tMaxZ: f32 = (bz - p0.z) * inv.z;

  let tDeltaX: f32 = abs(chunk_size_m * inv.x);
  let tDeltaY: f32 = abs(chunk_size_m * inv.y);
  let tDeltaZ: f32 = abs(chunk_size_m * inv.z);

  if (abs(rd.x) < EPS_INV) { tMaxX = BIG_F32; }
  if (abs(rd.y) < EPS_INV) { tMaxY = BIG_F32; }
  if (abs(rd.z) < EPS_INV) { tMaxZ = BIG_F32; }

  var best = HitGeom(false, BIG_F32, MAT_AIR, vec3<f32>(0.0));
  let t_exit_local = max(t_exit - start_t, 0.0);

  let max_chunk_steps = min((gd.x + gd.y + gd.z) * 6u + 8u, 1024u);

  for (var s: u32 = 0u; s < max_chunk_steps; s = s + 1u) {
    if (t_local > t_exit_local) { break; }

    let tNextLocal = min(tMaxX, min(tMaxY, tMaxZ));
    if (best.hit && (start_t + tNextLocal) >= best.t) { break; }

    let slot = grid_lookup_slot(cx, cy, cz);
    if (slot != INVALID_U32 && slot < cam.chunk_count) {
      let ch = chunks[slot];

      let cell_enter = start_t + t_local;
      let cell_exit  = start_t + min(tNextLocal, t_exit_local);

      let h = trace_chunk_hybrid_interval(ro, rd, ch, cell_enter, cell_exit);
      if (h.hit && h.t < best.t) { best = h; }
    }

    if (tMaxX < tMaxY) {
      if (tMaxX < tMaxZ) { cx += step_x; t_local = tMaxX; tMaxX += tDeltaX; }
      else               { cz += step_z; t_local = tMaxZ; tMaxZ += tDeltaZ; }
    } else {
      if (tMaxY < tMaxZ) { cy += step_y; t_local = tMaxY; tMaxY += tDeltaY; }
      else               { cz += step_z; t_local = tMaxZ; tMaxZ += tDeltaZ; }
    }

    let ox = cam.grid_origin_chunk.x;
    let oy = cam.grid_origin_chunk.y;
    let oz = cam.grid_origin_chunk.z;
    let nx = i32(cam.grid_dims.x);
    let ny = i32(cam.grid_dims.y);
    let nz = i32(cam.grid_dims.z);
    if (cx < ox || cy < oy || cz < oz || cx >= ox + nx || cy >= oy + ny || cz >= oz + nz) { break; }
  }

  // If no voxel hit, try heightfield clipmap fallback.
  let hf = clip_trace_heightfield(ro, rd, 0.0, FOG_MAX_DIST);

  let use_vox = best.hit;
  let use_hf  = (!best.hit) && hf.hit;

  let surface = select(
    sky,
    select(shade_clip_hit(ro, rd, hf), shade_hit(ro, rd, best), use_vox),
    (use_vox || use_hf)
  );

  let t_scene = select(
    min(t_exit, FOG_MAX_DIST),
    select(min(hf.t, FOG_MAX_DIST), min(best.t, FOG_MAX_DIST), use_vox),
    (use_vox || use_hf)
  );

  let T = fog_transmittance_primary(ro, rd, t_scene);
  let fogc = fog_color(rd);

  let fog_amt = (1.0 - T) * FOG_PRIMARY_VIS;
  let col = mix(surface, fogc, fog_amt);

  let ip = vec2<i32>(i32(gid.x), i32(gid.y));
  textureStore(color_img, ip, vec4<f32>(col, 1.0));
  textureStore(depth_img, ip, vec4<f32>(t_scene, 0.0, 0.0, 0.0));
}

@compute @workgroup_size(8, 8, 1)
fn main_godray(@builtin(global_invocation_id) gid: vec3<u32>) {
  let qdims = textureDimensions(godray_out);
  if (gid.x >= qdims.x || gid.y >= qdims.y) { return; }

  let fdims = textureDimensions(depth_tex);
  let ro = cam.cam_pos.xyz;

  let hip  = vec2<i32>(i32(gid.x), i32(gid.y));
  let qpx  = vec2<f32>(f32(gid.x), f32(gid.y));

  let frame = floor(cam.voxel_params.y * GODRAY_FRAME_FPS);
  let flip = select(
    0.0, 1.0,
    hash12(qpx * GODRAY_PATTERN_HASH_SCALE + vec2<f32>(frame, frame * 0.21)) > 0.5
  );

  let base_x = i32(gid.x) * GODRAY_BLOCK_SIZE;
  let base_y = i32(gid.y) * GODRAY_BLOCK_SIZE;

  let ax0 = select(1, 2, flip > 0.5);
  let ay0 = 1;
  let ax1 = select(3, 1, flip > 0.5);
  let ay1 = select(1, 2, flip > 0.5);
  let ax2 = select(1, 3, flip > 0.5);
  let ay2 = select(3, 2, flip > 0.5);
  let ax3 = select(3, 2, flip > 0.5);
  let ay3 = 3;

  let fp0 = vec2<i32>(clamp(base_x + ax0, 0, i32(fdims.x) - 1),
                      clamp(base_y + ay0, 0, i32(fdims.y) - 1));
  let fp1 = vec2<i32>(clamp(base_x + ax1, 0, i32(fdims.x) - 1),
                      clamp(base_y + ay1, 0, i32(fdims.y) - 1));
  let fp2 = vec2<i32>(clamp(base_x + ax2, 0, i32(fdims.x) - 1),
                      clamp(base_y + ay2, 0, i32(fdims.y) - 1));
  let fp3 = vec2<i32>(clamp(base_x + ax3, 0, i32(fdims.x) - 1),
                      clamp(base_y + ay3, 0, i32(fdims.y) - 1));

  let res_full = vec2<f32>(f32(fdims.x), f32(fdims.y));

  let j0 = (hash12(qpx * J0_SCALE + vec2<f32>(frame * J0_F.x, frame * J0_F.y)) - 0.5);
  let j1 = (hash12(qpx * J1_SCALE + vec2<f32>(frame * J1_F.x, frame * J1_F.y)) - 0.5);
  let j2 = (hash12(qpx * J2_SCALE + vec2<f32>(frame * J2_F.x, frame * J2_F.y)) - 0.5);
  let j3 = (hash12(qpx * J3_SCALE + vec2<f32>(frame * J3_F.x, frame * J3_F.y)) - 0.5);

  let t_scene0 = textureLoad(depth_tex, fp0, 0).x;
  let t_scene1 = textureLoad(depth_tex, fp1, 0).x;
  let t_scene2 = textureLoad(depth_tex, fp2, 0).x;
  let t_scene3 = textureLoad(depth_tex, fp3, 0).x;

  var acc = vec3<f32>(0.0);
  var wsum = 0.0;

  let t_end0 = min(t_scene0, GODRAY_MAX_DIST);
  if (t_end0 > 0.0 && fog_density_godray() > 0.0) {
    let px0 = vec2<f32>(f32(fp0.x) + 0.5, f32(fp0.y) + 0.5);
    acc += godray_integrate(ro, ray_dir_from_pixel(px0, res_full), t_end0, j0);
    wsum += 1.0;
  }

  let t_end1 = min(t_scene1, GODRAY_MAX_DIST);
  if (t_end1 > 0.0 && fog_density_godray() > 0.0) {
    let px1 = vec2<f32>(f32(fp1.x) + 0.5, f32(fp1.y) + 0.5);
    acc += godray_integrate(ro, ray_dir_from_pixel(px1, res_full), t_end1, j1);
    wsum += 1.0;
  }

  let t_end2 = min(t_scene2, GODRAY_MAX_DIST);
  if (t_end2 > 0.0 && fog_density_godray() > 0.0) {
    let px2 = vec2<f32>(f32(fp2.x) + 0.5, f32(fp2.y) + 0.5);
    acc += godray_integrate(ro, ray_dir_from_pixel(px2, res_full), t_end2, j2);
    wsum += 1.0;
  }

  let t_end3 = min(t_scene3, GODRAY_MAX_DIST);
  if (t_end3 > 0.0 && fog_density_godray() > 0.0) {
    let px3 = vec2<f32>(f32(fp3.x) + 0.5, f32(fp3.y) + 0.5);
    acc += godray_integrate(ro, ray_dir_from_pixel(px3, res_full), t_end3, j3);
    wsum += 1.0;
  }

  let cur = max(select(vec3<f32>(0.0), acc / wsum, wsum > 0.0), vec3<f32>(0.0));

  let hist = textureLoad(godray_hist_tex, hip, 0).xyz;

  let dmin = min(min(t_scene0, t_scene1), min(t_scene2, t_scene3));
  let dmax = max(max(t_scene0, t_scene1), max(t_scene2, t_scene3));
  let span = (dmax - dmin) / max(dmin, 1e-3);
  let edge = smoothstep(0.03, 0.15, span);

  let delta = length(cur - hist);
  let react = smoothstep(0.03, 0.18, delta);

  let stable = 1.0 - max(edge, react);

  let clamp_w = max(cur * 0.75, vec3<f32>(0.02));
  let hist_clamped = clamp(hist, cur - clamp_w, cur + clamp_w);

  let hist_w = clamp(GODRAY_TS_LP_ALPHA * stable, 0.0, 0.90);

  let blended = mix(cur, hist_clamped, hist_w);

  textureStore(godray_out, hip, vec4<f32>(blended, 1.0));
}

@compute @workgroup_size(8, 8, 1)
fn main_composite(@builtin(global_invocation_id) gid: vec3<u32>) {
  let dims = textureDimensions(out_img);
  if (gid.x >= dims.x || gid.y >= dims.y) { return; }

  let ip = vec2<i32>(i32(gid.x), i32(gid.y));
  let base = textureLoad(color_tex, ip, 0).xyz;

  let px = vec2<f32>(f32(gid.x) + 0.5, f32(gid.y) + 0.5);

  let g = godray_sample_bilerp(px);

  let gx = godray_sample_bilerp(px + vec2<f32>( 1.0, 0.0)) + godray_sample_bilerp(px + vec2<f32>(-1.0, 0.0));
  let gy = godray_sample_bilerp(px + vec2<f32>(0.0,  1.0)) + godray_sample_bilerp(px + vec2<f32>(0.0, -1.0));
  let blur = 0.25 * (gx + gy);

  var god_raw = max(g + COMPOSITE_SHARPEN * (g - blur), vec3<f32>(0.0));

  god_raw = max(god_raw - vec3<f32>(GODRAY_BLACK_LEVEL), vec3<f32>(0.0));

  let god = (vec3<f32>(1.0) - exp(-god_raw));

  let hdr = max(base + COMPOSITE_GOD_SCALE * god, vec3<f32>(0.0));
  let ldr = tonemap_exp(hdr);

  textureStore(out_img, ip, vec4<f32>(ldr, 1.0));
}

